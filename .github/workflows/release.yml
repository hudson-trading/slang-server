name: Release

on:
  workflow_dispatch:
    inputs:
      kind:
        description: 'Update kind (major, minor, patch)'
        required: true
        type: choice
        options:
          - patch
          - minor
          - major
        default: 'patch'

permissions:
  contents: write

jobs:
  create-release:
    runs-on: ubuntu-latest
    outputs:
      tag_name: ${{ steps.create_tag.outputs.tag_name }}
      version: ${{ steps.bump_version.outputs.version }}
    steps:
    - name: Checkout main branch
      uses: actions/checkout@v4
      with:
        ref: main
        fetch-depth: 0
        token: ${{ secrets.GITHUB_TOKEN }}

    - name: Bump version
      id: bump_version
      run: |
        # Read current version
        CURRENT_VERSION=$(cat VERSION)
        echo "Current version: $CURRENT_VERSION"

        # Parse version components
        IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT_VERSION"

        # Bump based on kind
        case "${{ github.event.inputs.kind }}" in
          major)
            MAJOR=$((MAJOR + 1))
            MINOR=0
            PATCH=0
            ;;
          minor)
            MINOR=$((MINOR + 1))
            PATCH=0
            ;;
          patch)
            PATCH=$((PATCH + 1))
            ;;
        esac

        NEW_VERSION="$MAJOR.$MINOR.$PATCH"
        echo "New version: $NEW_VERSION"
        echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT

    - name: Update VERSION file
      run: |
        VERSION="${{ steps.bump_version.outputs.version }}"
        echo "$VERSION" > VERSION
        echo "Updated VERSION to: $VERSION"
        cat VERSION

    - name: Commit VERSION update
      run: |
        VERSION="${{ steps.bump_version.outputs.version }}"
        git config user.name "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"
        git add VERSION
        git commit -m "Update VERSION to $VERSION"
        git push origin main
        echo "Committed VERSION update to main"

    - name: Create and push tag
      id: create_tag
      run: |
        VERSION="${{ steps.bump_version.outputs.version }}"
        TAG_NAME="v$VERSION"
        git tag "$TAG_NAME"
        git push origin "$TAG_NAME"
        echo "Created and pushed tag: $TAG_NAME"
        echo "tag_name=$TAG_NAME" >> $GITHUB_OUTPUT

    - name: Create GitHub release
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        TAG_NAME="${{ steps.create_tag.outputs.tag_name }}"
        gh release create "$TAG_NAME" \
          --title "$TAG_NAME" \
          --generate-notes \
          --draft=false \
          --prerelease=false
        echo "Created GitHub release: $TAG_NAME"

  build:
    needs: create-release
    uses: ./.github/workflows/build.yml
    with:
      upload_artifacts: true
      ref: main  # Build from main branch with updated VERSION

  add-release-assets:
    needs: [create-release, build]
    runs-on: ubuntu-latest

    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        token: ${{ secrets.GITHUB_TOKEN }}

    - name: Download all artifacts
      uses: actions/download-artifact@v4
      with:
        path: artifacts

    - name: Prepare release assets
      id: prepare
      run: |
        mkdir -p release-assets
        if [ -d artifacts ]; then
          find artifacts -type f \( -name "*.tar.gz" -o -name "*.zip" \) -exec cp {} release-assets/ \; 2>/dev/null || true
        fi
        if [ -z "$(ls -A release-assets 2>/dev/null)" ]; then
          echo "Warning: No release artifacts found"
          echo "has_artifacts=false" >> $GITHUB_OUTPUT
        else
          echo "has_artifacts=true" >> $GITHUB_OUTPUT
          ls -lh release-assets/
        fi

    - name: Get release info
      if: steps.prepare.outputs.has_artifacts == 'true'
      id: release
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        TAG_NAME="${{ needs.create-release.outputs.tag_name }}"
        echo "tag=$TAG_NAME" >> $GITHUB_OUTPUT

        # Get existing release notes
        RELEASE_NOTES=$(gh release view "$TAG_NAME" --json body -q .body)
        echo "notes<<EOF" >> $GITHUB_OUTPUT
        echo "$RELEASE_NOTES" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT

    - name: Generate checksums and update release
      if: steps.prepare.outputs.has_artifacts == 'true'
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        TAG_NAME="${{ steps.release.outputs.tag }}"

        # Generate checksums
        cd release-assets
        CHECKSUMS=$(sha256sum * | sed 's/^/    /')
        cd ..

        # Append checksums to release notes
        cat > updated-notes.md << 'EOF'
        ${{ steps.release.outputs.notes }}

        ## Checksums

        ```
        EOF
        echo "$CHECKSUMS" >> updated-notes.md
        echo '```' >> updated-notes.md

        # Update release with checksums and upload artifacts
        gh release edit "$TAG_NAME" --notes-file updated-notes.md
        gh release upload "$TAG_NAME" release-assets/* --clobber
