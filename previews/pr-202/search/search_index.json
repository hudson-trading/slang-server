{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p><code>slang-server</code> is a high-performance Language Server Protocol (LSP) implementation for SystemVerilog, built on top of the Slang SystemVerilog frontend.</p>"},{"location":"#overview","title":"Overview","text":"<p>slang-server provides comprehensive SystemVerilog language support for modern editors and IDEs, including:</p> <ul> <li>Real-time diagnostics and linting</li> <li>Code completions (IntelliSense)</li> <li>Go-to definition and Go-to references</li> <li>Symbol search and workspace indexing</li> <li>Hardware-specific language features via custom editor clients</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":"<p>Check out the installation guide and learn how to configure your editor.</p>"},{"location":"#project-status","title":"Project Status","text":"<p><code>slang-server</code> is actively developed by the hardware team at Hudson River Trading and welcomes community contributions. The project aims to be the most comprehensive and performant SystemVerilog language server.</p>"},{"location":"#support-contributing","title":"Support &amp; Contributing","text":"<ul> <li>Bug Reports: Open an issue on GitHub</li> <li>Contributing: Pull requests are welcome! See our contributing guidelines.</li> </ul>"},{"location":"#license","title":"License","text":"<p>slang-server is licensed under the MIT License. See the full license for details.</p>"},{"location":"features/features/","title":"Language Features","text":""},{"location":"features/features/#diagnostics","title":"Diagnostics","text":"<p>Diagnostics are provided by slang using Shallow Compilations when a design is not set. When a design is set, the shallow compilation provides diagnostics on each keystroke, and the design's compilation provides diagnostics on each save.</p> <p></p>"},{"location":"features/features/#hovers-and-go-to-definition","title":"Hovers and Go-to Definition","text":"<p>Hovers are provided on each symbol with the following info if applicable:</p> <ul> <li>Symbol kind, or Syntax kind in the case of macros.</li> <li>Lexical Scope, or file in the case of macros.</li> <li>Resolved type info</li> <li>Bitwidth, if a value or type</li> <li>Value, if a constant value</li> <li>The syntax that the symbol is derived from</li> <li>Macro usage, if symbol was defined from one.</li> </ul> <p></p> <p>Planned features:</p> <ul> <li>Multiple definitions, for example with modports.</li> <li>Macro expansion on hover, with expand quick-action</li> <li>Hovers/Gotos for struct assignments</li> <li>Hovers for builtins</li> </ul>"},{"location":"features/features/#completions","title":"Completions","text":"<p>Completions are currently provided for the following constructs:</p> <ul> <li>Generic expression completions: parameters, variables, types etc.</li> <li>Modules and interfaces</li> <li>Functions and macros</li> <li>Hierarchical references and struct members</li> </ul> <p></p> <p>Planned completions:</p> <ul> <li>Named assignments (structs, functions, ports, params)</li> <li>builtins (<code>$bits()</code>, etc.)</li> </ul>"},{"location":"features/features/#go-to-references-rename","title":"Go-to References / Rename","text":"<p>Go-to references are provided for every nearly all symbols except for macros. Keep in mind this is an expensive operation, and may take some time for a large repo.</p> <p></p>"},{"location":"features/features/#inlay-hints","title":"Inlay Hints","text":"<p>Inlay hints are text that show up inline in the code to provide useful info. They can be hovered for more info, and some can be double clicked to insert some text.</p> <p>Ports Types - Show the type of ports in instances (off by default)</p> <p></p> <p>Wildcard Ports - Show which signals are passed through </p> <p>Positional args in Macros, Functions, Paramter/Port lists - Show the argument names </p> <p>Planned Inlays:</p> <ul> <li>Constant Values - Show parameter values and resolved types</li> <li>Signals - Show the value when a waveform is connected and an instance is selected.</li> <li>Wildcard Imports - Show which symbols are used from the import</li> </ul>"},{"location":"features/features/#planned-lsp-methods","title":"Planned LSP Methods:","text":"<p>Semantic Token Highlighting This will provide additional coloring for variable names, distinguishing between wires, registers, and parameters. For classes/functions it will distinguish betweeen instance variables, function args and locals.</p> <p>Formatting This will likely live in the slang repo and also be shipped as a standalone binary. In order to have fairly nice formatting in hovers and completions, basic formatting functions already exist in this repo. This includes things like squashing white spaces to condense hover and completion types, and left aligning blocks of text for hovers and completion docs.</p>"},{"location":"features/limitations/","title":"Limitations","text":"<p>Potential Shallow Compilation Issues</p> <p>In shallow compilations some nodes may be invalid due to unset parameters, missing defines, etc. Therefore some expressions may not be visited by slang and cause some false positives, especially with unused checking. These can often be fixed, so please raise an issue if you see one. Before raising an issue, please check whether it shows up via a normal slang command to determine which repo to raise the issue in.</p> <p>Untaken Ifdef Branches</p> <p>Features may be limited in the context of untaken ifdef branches. To minimize this, it's recommended to encode these ifdefs in package parameters, then use generate blocks in the hdl code. Or if these are single branch ifdefs, include the most permissible defines in your server config.</p> <p>Deep Hierarchical References</p> <p>Shallow compilations only load the directly referenced syntax trees, and only load more transitive trees through packages. This may therefore cause issues with deep hierarchical references.</p> <p>Single Unit Compilations</p> <p>Designs that use slang's <code>--single-unit</code> are not be supported. The main effect this tends to have is that macros are not inherited and so diagnostics will occur there. This flag means that all files are essentially concatenated before being sent to tools. Even if <code>slang-server</code> grabbed these dependencies, it would make file and compilation updates take much longer, so it's generally preferred to switch away from using this flag.</p> <p>Some UVM Code</p> <p>The common UVM practice where classes are `included in a package results in poor support for those classes.</p>"},{"location":"features/design/indexing/","title":"Workspace Indexing","text":"<p>slang-server's indexing system provides fast symbol lookup and navigation across large SystemVerilog codebases by building and maintaining an index of top level symbols.</p> <p>The indexer uses multithreading to rapidly index your repo. Crawling a file system actually often takes longer than parsing in large unconfigured repos, so make sure your indexing config is as specific as possible.</p> <p>In each syntax tree parsed, it indexes the top level symbols like moduldes, packages, etc, as well as references to other top level symbols. If no top level symbols were found, it'll instead index the macros defined in that file.</p>"},{"location":"features/design/shallow/","title":"Shallow Compilation","text":"<p>In order to provide real time diagnostics and symbols, the server makes use of the concept of a shallow compilation, where directly referenced top level symbols in the current document are loaded for use in a slang compilation.</p> <p>In software languages this is typically standard- you can compile just one cpp file for example, and forward declare other symbols that you use. This isn't really a thing for HDLs, where a full design is almost always assumed. Parts of Slang can be tweaked to essentially get this functionality.</p>"},{"location":"features/design/shallow/#limitations","title":"Limitations","text":"<p>Hierarchical references can go down or up more than one layer, in which case some symbols may not load. It would be nice to continue adding the relevant syntax trees to get all symbols in the current document, rather than just loading directly referenced symbols. Upward references will always be a blind spot for the language server when a design isn't set, and are generally not considered a good practice.</p>"},{"location":"features/design/shallow/#allgeneratebranches","title":"AllGenerateBranches","text":"<p>This compilation flag is used in shallow compilations to get symbols and diagnostics on all generate branches. This process can definitely be improved; for example certain diags are marked as invalid for shallow compilation, and that's tricky since some may have been missed, and ideally the system would never go down the path where it's publishing those diags.</p> <p>A related issue is the case of ifdef branches. Making an AllIfdefBranches flag would certainly cause chaos, and perhaps the best way of dealing with this is to just do syntax lookups in the untaken branches to provide symbols.</p>"},{"location":"features/design/shallow/#interface-port-parameter-asserts","title":"Interface Port Parameter Asserts","text":"<p>It's a common pattern to declare an input/output interface with a datatype, however SystemVerilog doesn't let you restrict the params of these interface ports, and people instead rely on asserts. Ideally slang could pick up on these asserts and fill in the correct dtype for these. Even more ideally, these constraints would be in the language itself. Either implementation would provide the user with more accurate info when doing hierarhical completions.</p>"},{"location":"features/design/shallow/#single-unit","title":"Single Unit","text":"<p>The slang <code>--single-unit</code> causes all parsed files to essentially be squashed together, which has the effect of syntax trees inheriting preprocessor macros and defines.</p> <p>Actually parsing the files this way in the language server would slow down the server considerably. So repos that use this will see errors for symbols - typically macros - that are not explicitly included.</p> <p>Support for this could be added in the future by feeding the indexed macros to the preprocessor if it can't find the macro in its current working set.</p>"},{"location":"features/hdl/api/","title":"External Tools","text":"<p>There have been requests to integrate external tools with the slang language server. While integrations have only been made with waveform viewers so far, these are guidlines for how one would go about adding more integrations.</p> <p>Integrations are typically working with a slang compilation (elaborated design), since these are an hdl-specific construct and outside the scope of the LSP.</p> <p>In general it's preferred for the <code>slang-server</code> to initiate the handshake, since a user will likely always start with their editor, and move to more advanced tools when necessary.</p>"},{"location":"features/hdl/api/#vscode-only-integrations","title":"Vscode-only Integrations","text":"<p>Vscode apis can easily be exposed via hidden commands that aren't shown to the user. See <code>ProjectComponent.ts</code> for examples of some commands. Some new routes may need to be added to the server-client interface as well in <code>SlangInterface.ts</code></p> <p>In order to provide type safe API access, the <code>activate()</code> function should be changed to expose an API object that has both the server and client's routes.</p> <p>There should be an api exposed to subscribe within this to changes to which filelist is set, as well as when updated slang compilations are available.</p>"},{"location":"features/hdl/api/#slang-cpp-integrations","title":"Slang Cpp Integrations","text":"<p>Similarly, it would be ideal to subscribe to a compilation and receive updates within in C++. The server should share a non-owning reference to the compilation over shared memory, which has yet to be implemented.</p>"},{"location":"features/hdl/api/#other-integrations","title":"Other Integrations","text":"<p>One can look to the Surfer wcp work for implementing an editor-agnostic and implementation-language-agnostic integration over JsonRPC.</p>"},{"location":"features/hdl/hdl/","title":"Hardware Language Features","text":"<p>When a design is set, a full hierarchy will be elaborated in conjunction with the shallow compilations per file, which will still be used to get quick language features on all tokens.</p> <p>The compilation is refreshed on save, updating the diagnostics and related info.</p> <p>See the Vscode Docs</p> <p>See the Neovim Docs</p> <p></p>"},{"location":"features/hdl/neovim/","title":"Hardware Language Features - Neovim","text":"<p>All features listed here require the Neovim plugin.  See the installation guide for how to get started. Once installed the <code>SlangServer</code> command will provide a number of subcommands outlined below.</p>"},{"location":"features/hdl/neovim/#setting-a-compilation","title":"Setting a Compilation","text":""},{"location":"features/hdl/neovim/#setting-a-build-file","title":"Setting a build file","text":"<pre><code>:SlangServer setBuildFile BUILDFILE\n</code></pre> <p>This uses the file located at `BUILDFILE`` to compile a full hierarchy and is required for some of the commands below.</p>"},{"location":"features/hdl/neovim/#setting-a-top-level","title":"Setting a top level","text":"<pre><code>:SlangServer setTopLevel [TOPFILE]\n</code></pre> <p>This uses a file to run a compilation using the top-most module in the provided file.  If <code>TOPFILE</code> is not provided the file from the current buffer will be used.</p>"},{"location":"features/hdl/neovim/#hierarchyview","title":"HierarchyView","text":"<pre><code>:SlangServer hierarchy [SCOPE]\n</code></pre> <p>This will open the hierarchy view and, if <code>SCOPE</code> is provided, expand the view to that scope.</p> <p></p>"},{"location":"features/hdl/neovim/#cone-tracing-experimental","title":"Cone Tracing (experimental)","text":"<p><pre><code>:lua vim.lsp.buf.incoming_calls()\n</code></pre> <pre><code>:lua vim.lsp.buf.outgoing_calls()\n</code></pre></p> <p>This allows for drivers/loads tracing over the call hierarchy lsp route, since it's an analogous concept.  Tracing incoming calls yields drivers of a given signal and outgoing calls yields loads or things the signal drives. Calling one of these functions will trace the signal currently under the cursor. If there is more than one instance of the signal then first a list of instances will be presented. After an instance is selected (or if there is only one instance) a list of drivers or loads will be presented.</p>"},{"location":"features/hdl/neovim/#waveform-integration-experimental","title":"Waveform Integration (experimental)","text":"<p><code>slang-server</code> can interact with waveform viewers via the WCP (waveform control protocol). The only known implementation of WCP is currently in Surfer.</p>"},{"location":"features/hdl/neovim/#editor-features","title":"Editor Features","text":""},{"location":"features/hdl/neovim/#open-waveform-file","title":"Open Waveform File","text":"<pre><code>:SlangServer openWaveform WAVEFILE\n</code></pre> <p>This opens the waveform file (e.g. VCD or FST) indicated by <code>WAVEFILE</code>. If there is no currently active WCP session a new waveform viewer will be launched using the command provided in the <code>wcpCommand</code> config field. By default this is Surfer. If a WCP session already exists, the new waveform file will be loaded. Additionally, if a <code>buildPattern</code> config field is provided, the build file which corresponds to the current wave file will be used to produce a compilation. E.g. given a wave file of <code>/some/dir/foo.fst</code> and a <code>buildPattern</code> of <code>/some/other/dir/{}.f</code> and compilation will be made using <code>/some/other/dir/foo.f</code>.</p>"},{"location":"features/hdl/neovim/#add-item","title":"Add Item","text":"<pre><code>:SlangServer addToWaves [RECURSIVE]\n</code></pre> <p>Adds the signal, module, interface or other scope currently under the cursor to the waveform viewer. If <code>RECURSIVE</code> is provided and is <code>true</code> and the item is a scope it will be added recursively. If more than one instance of the item exists, a list of instances will be provided to choose from.</p>"},{"location":"features/hdl/neovim/#wave-viewer-features","title":"Wave Viewer Features","text":"<ul> <li>Goto Definition</li> <li>Add Drivers</li> <li>Add Loads</li> </ul>"},{"location":"features/hdl/vscode/","title":"Hardware Language Features - Vscode","text":""},{"location":"features/hdl/vscode/#setting-a-compilation","title":"Setting a Compilation","text":""},{"location":"features/hdl/vscode/#setting-a-build-file","title":"Setting a build file","text":"<p>A build pattern can be configured to glob for .f files based on your build system. The default is <code>**/*.f</code>. Then you can run the \"Select Build File\" Command from the hierarchy view or as a general command.</p>"},{"location":"features/hdl/vscode/#setting-a-top-level","title":"Setting a top level","text":"<p>The 'chip' icon at the top right of a file will scan the current file for valid top levels, and find all necessary files for a compilation.</p> <p></p>"},{"location":"features/hdl/vscode/#hierarchy-view","title":"Hierarchy View","text":"<p>The Hierarchy View shows the elaborated tree, with declared types and resolved values to the right of the identifier. Clicking a symbol in the hierarchy view or modules view will open the instance in the file, as well as in the other view.</p> <p>Hierarchy Buttons (left to right):</p> <ul> <li>Clear top level</li> <li>Select Instance</li> <li>Open selected build file</li> <li>Select build file (from glob)</li> <li>Toggle data signals</li> <li>Toggle symbols defined behind macro usages.</li> <li>Toggle parameters</li> <li>Collapse all</li> </ul> <p>Tree Item Buttons</p> <ul> <li>Open in waveform (or press <code>w</code>)<ul> <li>For scopes, this will add the children recursively</li> <li>Some signals like structs may not open, this will be fixed in a future release</li> </ul> </li> <li>Open Module - This will open the module rather than the instance</li> <li>Copy path (<code>cmd+c</code>, or right click &gt; copy path)</li> </ul> <p>Vaporview Buttons</p> <p>Vaporview is a vscode waveform viewer that integrates with <code>slang-server</code>.</p> <ul> <li>Open in Editor (or press <code>e</code> with selected signal)</li> <li>At the moment, pressing <code>e</code> only works on selected signal, not selected netlist item</li> </ul> <p></p>"},{"location":"features/hdl/vscode/#modules-view","title":"Modules View","text":"<p>The modules view shows the instances indexed by module, sorted by the number of instances with higher level objects closer to the top.</p> <p>While a compilation is active, the modules view will open when switching text documents, allowing the user to select which instance of that module they'd like to focus on. In the future, inlay hints will show values for parameters and signals in the source code.</p> <p></p>"},{"location":"features/hdl/vscode/#setting-an-instance","title":"Setting an Instance","text":""},{"location":"features/hdl/vscode/#slang-select-instance-command","title":"<code>slang: Select Instance</code> Command","text":"<p>This command pulls up a fuzzy finder where you can enter the hierarchical path of a scope/instance.</p> <p>It's also available via the magnifying glass icon in the Hierachy view, or by pressing <code>cmd+f</code> while the sidebar is in focus.</p> <p></p>"},{"location":"features/hdl/vscode/#terminal-links","title":"Terminal Links","text":"<p>Hierarchical paths are automatically recognized for vscode-integrated terminals. Clicking on these will set the compilation based on the top name as well as the instance. Even if the exact instance can't be found, it will eagerly open the instance and show an error on the invalid id.</p> <p></p>"},{"location":"start/config/","title":"Configuration","text":"<p>The server uses a hierarchical configuration system, layering configs in this order:</p> <ol> <li><code>~/.slang/server.json</code></li> <li><code>${workspaceFolder}/.slang/server.json</code> (should be in source control)</li> <li><code>${workspaceFolder}/.slang/local/server.json</code> (<code>.slang/local</code> should be ignored by source control)</li> </ol> <p>Each option value overrides the value set in previous configs. The exception for this is lists, which are appended.</p>"},{"location":"start/config/#config-options","title":"Config Options","text":"<p>All configuration options are optional and have sensible defaults. In VSCode, there are completions and hovers for <code>server.json</code> files. For other editors, you may be able to associate the config schema with these config files to get these features.</p>"},{"location":"start/config/#index","title":"<code>index</code>","text":"<p>Type: <code>list[IndexConfig]</code></p> <pre><code>interface IndexConfig {\n  /** Directories to index */\n  dirs?: string[]\n  /** Directories to exclude; only supports single directory names and applies to all path levels */\n  excludeDirs?: string[] | null\n}\n</code></pre> <p>Which directories to index; By default it indexes the entire workspace. It's highly recommended to configure this for your repo, especially if there are generated build directories and non-hardware directories that can be skipped.</p>"},{"location":"start/config/#flags","title":"<code>flags</code>","text":"<p>Type: <code>string</code></p> <p>Flags to pass to slang.</p> <p>It's recommended to keep your slang flags in a flag file, that way it can be shared by both CI and the language server. Another nice setup is having <code>slang.f</code> contain your CI flags, then have <code>slang-server.f</code> include that file (via <code>-f path/to/slang.f</code>), along with more warnings in <code>slang-server.f</code>. That way more pedantic checks will show as yellow underlines in your editor.</p> <p>Example: <code>\"-f path/to/slang_flags.f\"</code></p>"},{"location":"start/config/#indexingthreads","title":"<code>indexingThreads</code>","text":"<p>Type: <code>integer</code></p> <p>Default: <code>0</code> (auto-detect)</p> <p>Thread count to use for indexing. When set to 0, automatically detects the optimal number of threads based on system capabilities.</p>"},{"location":"start/config/#parsingthreads","title":"<code>parsingThreads</code>","text":"<p>Type: <code>integer</code></p> <p>Default: <code>8</code></p> <p>Thread count to use for parsing SystemVerilog files for compilations.</p>"},{"location":"start/config/#build","title":"<code>build</code>","text":"<p>Type: <code>string</code></p> <p>Build file to automatically open on start.</p> <p>Example: <code>\"./build/compile.f\"</code></p>"},{"location":"start/config/#buildpattern","title":"<code>buildPattern</code>","text":"<p>Type: <code>string</code> (glob pattern)</p> <p>Build file pattern used to find a <code>.f</code> file given the name of a waveform file. For example, <code>/tmp/{}.fst</code> with <code>builds/{}.f</code> looks for <code>build/foo.f</code> to load the compilation. This is also used to look for <code>.f</code> files in the VSCode client when selecting a <code>.f</code> file.</p> <p>Example: <code>\"builds/{}.f\"</code></p>"},{"location":"start/config/#wcpcommand","title":"<code>wcpCommand</code>","text":"<p>Type: <code>string</code></p> <p>Waveform viewer command where <code>{}</code> will be replaced with the WCP port.</p> <p>Example: <code>\"surfer --wcp-initiate {}\"</code></p>"},{"location":"start/config/#example-configuration","title":"Example Configuration","text":"<pre><code>{\n  \"flags\": \"-f tools/slang/slang-server.f\",\n  \"indexGlobs\": [\"./src/**/*.sv\", \"./tb/**/*.sv\"],\n  \"excludeDirs\": [\"build\", \"obj_dir\"],\n  \"indexingThreads\": 4,\n  \"parsingThreads\": 8,\n  \"build\": \"./scripts/compile.f\",\n  \"wcpCommand\": \"surfer --wcp-initiate {}\"\n}\n</code></pre>"},{"location":"start/installing/","title":"Installing","text":""},{"location":"start/installing/#build-from-source","title":"Build from Source","text":"<pre><code># Clone the repository\ngit clone https://github.com/hudson-trading/slang-server.git\ncd slang-server\n\n# Pull dependencies (slang and reflect-cpp)\ngit submodule update --init --recursive\n\n# Build with cmake using a C++20 compliant compiler\ncmake -B build -DCMAKE_BUILD_TYPE=Release\ncmake --build build -j --target slang_server\n</code></pre> <p>On certain systems (Arch, etc), you may need to have the project use its vendored copy of the <code>fmt</code> library, rather than the one on your system. This can be achieved by appending <code>-DCMAKE_DISABLE_FIND_PACKAGE_fmt=TRUE</code> to the CMake configuration step, e.g.:</p> <pre><code>cmake -B build -DCMAKE_BUILD_TYPE=Release -DCMAKE_DISABLE_FIND_PACKAGE_fmt=TRUE\n</code></pre> <p>In the future there will be pre-built binaries released for common platforms. The editor clients will auto-install these, similar to what clangd and others do.</p> <p>Windows: At the moment there are issues running on windows; See #115 and related issues.</p>"},{"location":"start/installing/#vscode","title":"Vscode","text":"<p>Install the extension here, then set <code>slang.path</code> to the slang-server binary. (at <code>build/bin/slang-server</code>)</p> <p>See VSCode Options</p>"},{"location":"start/installing/#vscode-forks-cursor-antigravity-vscodium-etc","title":"Vscode Forks (Cursor, Antigravity, VSCodium, etc.)","text":"<p>Install from your editor, or download from the OpenVSX Marketplace</p>"},{"location":"start/installing/#neovim","title":"Neovim","text":"<p>Once Slang Server is more actively used (you can help by starring the project!), it will be added to nvim-lspconfig and mason.nvim and no additional configuration will be required. Until then, follow one of the methods below to manually add the server configuration.</p> <p>For newer versions of Neovim (\u2265 v0.11), the new vim.lsp API is the preferred, simpler way to configure language servers: <pre><code>vim.lsp.config(\"slang-server\", {\n  cmd = { \"slang-server\" },\n  root_markers = { \".git\", \".slang\" },\n  filetypes = {\n    \"systemverilog\",\n    \"verilog\",\n  },\n})\n\nvim.lsp.enable(\"slang-server\")\n</code></pre></p> <p>For older versions of Neovim (&lt; v0.11) with <code>nvim-lspconfig</code>, the server can be configured with: <pre><code>local configs = require(\"lspconfig.configs\")\nlocal util = require(\"lspconfig.util\")\n\nif not configs.slang_server then\n  configs.slang_server = {\n    default_config = {\n      cmd = {\n        \"slang-server\",\n      },\n      filetypes = {\n        \"systemverilog\",\n        \"verilog\",\n      },\n      single_file_support = true,\n      root_dir = function(fname)\n        return util.root_pattern(\".git\", \".slang\")(fname)\n      end,\n    },\n  }\nend\n</code></pre></p> <p>For users of lazy.nvim, the above could be added to their <code>nvim-lspconfig</code> spec at <code>~/.config/nvim/lua/plugins/nvim-lspconfig.lua</code> like this: <pre><code>return {\n  \"neovim/nvim-lspconfig\",\n  opts = {\n    setup = {\n      slang_server = function(_, opts)\n        local configs = require(\"lspconfig.configs\")\n        local util = require(\"lspconfig.util\")\n\n        if not configs.slang_server then\n          configs.slang_server = {\n            default_config = {\n              cmd = {\n                \"slang-server\",\n              },\n              filetypes = {\n                \"systemverilog\",\n                \"verilog\",\n              },\n              single_file_support = true,\n              root_dir = function(fname)\n                return util.root_pattern(\".git\", \".slang\")(fname)\n              end,\n            },\n          }\n        end\n      end,\n    },\n    servers = {\n      slang_server = {\n        enabled = true,\n        mason = false,\n      },\n    },\n  },\n}\n</code></pre></p> <p>Pointing at the binary is all you need for standard language features, however a plugin is provided to enable some client-side features which extend the LSP (e.g. the hierarchy view, waveform integration). The plugin can be found in <code>clients/neovim/</code> and is also mirrored in slang-server.nvim for ease of use with Neovim plugin managers.</p>"},{"location":"start/installing/#other-editors","title":"Other editors","text":"<p>Most modern editors can at least point to a language server binary for specific file types. This will provide standard LSP features, but not HDL specific  features.</p> <p>If the editor also allows for executing LSP commands, HDL features like setting a compilation should be available.</p>"}]}