{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p><code>slang-server</code> is a high-performance Language Server Protocol (LSP) implementation for SystemVerilog, built on top of the Slang SystemVerilog frontend.</p>"},{"location":"#overview","title":"Overview","text":"<p>slang-server provides comprehensive SystemVerilog language support for modern editors and IDEs, including:</p> <ul> <li>Real-time diagnostics and linting</li> <li>Code completion and IntelliSense</li> <li>Go-to definition and Hover Info</li> <li>Symbol search and workspace indexing</li> <li>Hardware-specific language extensions</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":"<p>Ready to get started? Check out our installation guide and learn how to configure your editor.</p>"},{"location":"#project-status","title":"Project Status","text":"<p>slang-server is actively developed by the hardware team at Hudson River Trading and welcomes community contributions. The project aims to provide the most comprehensive and performant SystemVerilog language server available.</p>"},{"location":"#support-contributing","title":"Support &amp; Contributing","text":"<ul> <li>Bug Reports: Open an issue on GitHub</li> <li>Contributing: Pull requests are welcome! See our contributing guidelines.</li> </ul>"},{"location":"#license","title":"License","text":"<p>slang-server is licensed under the MIT License. See the full license for details.</p>"},{"location":"design/indexing/","title":"Workspace Indexing","text":"<p>slang-server's indexing system provides fast symbol lookup and navigation across large SystemVerilog codebases by building and maintaining an index of top level symbols.</p>"},{"location":"design/indexing/#how-it-works","title":"How it works","text":"<p>The Indexer indexes based on these config options on startup:</p> <ul> <li><code>indexGlobs</code> (default: <code>\"./.../*.sv*\"</code>)</li> <li><code>excludeDirs</code> (default: <code>[]</code>)</li> </ul> <p>It uses multithreading to rapidly index your repo. Crawling a file system actually often takes longer than parsing, so make sure these are as specific as possible.</p> <p>In each syntax tree parsed, it indexes the top level symbols like moduldes, packages, etc. If no top level symbols were found, it'll instead index the macros defined in that file.</p> <p>In the future, this will also index the referenced top level symbols to enable the go-to references feature.</p>"},{"location":"design/shallow/","title":"Shallow Compilation","text":"<p>In order to provide real time diagnostics and symbols, the server makes use of the concept of a shallow compilation, where directly referenced top level symbols in the current document are loaded for use in a slang compilation.</p> <p>In software languages this is typically standard- you can compile just one cpp file for example, and forward declare other symbols that you use. This isn't really a thing for HDLs, where a full design is almost always assumed. Parts of Slang can be tweaked to essentially get this functionality.</p>"},{"location":"design/shallow/#limitations","title":"Limitations","text":"<p>Hierarchicaly references can go down or up more than one layer, in which case some symbols may not load. It would be nice to continue adding the relevant syntax trees to get all symbols in the current document, rather than just loading directly referenced symbols. Upward references will always be a blind spot for the language server, and are generall not considered a good practice.</p>"},{"location":"design/shallow/#allgeneratebranches","title":"AllGenerateBranches","text":"<p>This compilation flag is used in shallow compilations to get symbols and diagnostics on all generate branches. This process can definitely be improved; for example certain diags are marked as invalid for shallow compilation, and that's tricky since some may have been missed, and ideally the system would never go down the path where it's publishing those diags.</p> <p>A related issue is the case of ifdef branches. Making an AllIfdefBranches flag would certainly cause chaos, and perhaps the best way of dealing with this is to just do syntax lookups in the untaken branches to provide symbols.</p>"},{"location":"design/shallow/#interface-port-parameter-asserts","title":"Interface Port Parameter Asserts","text":"<p>It's a common pattern to declare an input/output interface with a datatype, however SystemVerilog doesn't let you restrict the params of these interface ports, and people instead rely on asserts. Ideally slang could pick up on these asserts and fill in the correct dtype for these. Even more ideally, these constraints would be in the language itself. Either implementation would provide the user with more accurate info when doing hierarhical completions.</p>"},{"location":"design/shallow/#single-unit","title":"Single Unit","text":"<p>The slang <code>--single-unit</code> causes all parsed files to essentially be squashed together, which has the effect of syntax trees inheriting preprocessor macros and defines.</p> <p>This isn't great for a language server, and isn't supported at the moment, meaning repos that use this will see errors for undefined macros.</p> <p>Support for this could be added by feeding the indexed macros to the preprocessor if it can't find the macro in its current working set.</p>"},{"location":"features/completions/","title":"Completion Examples","text":""},{"location":"features/features/","title":"Feature Support","text":"<p>slang-server provides comprehensive Language Server Protocol (LSP) support for SystemVerilog, offering modern IDE features that significantly enhance development productivity.</p>"},{"location":"features/features/#symbol-specific-feature-support","title":"Symbol-Specific Feature Support","text":"<p>| Symbol Type          | GoTo              | Hover | Completion | Notes                                       | | -------------------- | ----------------- | ----- | ---------- | ------------------------------------------- | ------------------------- | -------------- | -------------------------- | --- | | Modules          | \u2705                | \u2705    | \u2705         |                                             | | Interfaces       | \u2705                | \u2705    | \u2705         |                                             | | Classes          | \ud83d\udfe1                | \ud83d\udfe1    | \ud83d\udfe1         |                                             | | Functions/Tasks  | \u2705                | \u2705    | \ud83d\udfe1         | Completions can be improved with signatures | | Scope Variables  | \u2705                | \u2705    | \u2705         |                                             | | Ports            | \u2705                | \u2705    | \u274c         | Completions planned for ports on instances  | | Parameters       | \u2705                | \u2705    | \u274c         | Completions planned for params on instances | | Typedefs         | \u2705                | \u2705    | \u26aa         | Custom type definitions                     | | Enums            | \u2705                | \u2705    | \u26aa         | Enumeration values                          | | Packages         | \u2705                | \u2705    | \u2705         | Completions for package members             | | Wildcard Imports | \u2705                | \u2705    | \u2705         | Completions for imported members            | | Macros           | \ud83d\udfe1                | \u2705    | \u2705         | Indexed macro completions                   | | System Tasks     | \u26aa                | \u274c    | \u274c         | Planned                                     | |                         | |                        | |  |</p>"},{"location":"features/hovers/","title":"Hover Examples","text":""},{"location":"features/planned/","title":"Planned Features","text":""},{"location":"features/planned/#goto-references","title":"Goto references","text":"<p>This will start out with top level symbols like macros, modules, packages, and interfaces, then work it's way into scope members</p>"},{"location":"features/planned/#semantic-token-highlighting","title":"Semantic Token Highlighting","text":"<p>This will provide additional coloring for variable names, distinguisihing between wires, registers, and parameters.</p> <p>For classes/functions it will distinguish betweeen instance variables, function args and locals.</p>"},{"location":"features/planned/#inlay-hints","title":"Inlay Hints","text":"<p>Ports - Show the type of ports in instances</p> <p>Params - Show the resolved value of parameters</p> <p>Signals - Show the resolved type of wires and registers, and show the value when a waveform is connected</p> <p>Macros/Functions - Show the positional argument names</p> <p>Wildcard Ports - Show which signals are passed through</p> <p>Wildcard Imports - Show which symbols are imported</p>"},{"location":"features/planned/#formatter","title":"Formatter","text":"<p>This one is pretty self explanatory.</p>"},{"location":"hdl/hdl/","title":"Hardware Language Features","text":"<p>When a compilation is set, a proper compilation will be made on top of the shallow compilations per file. The shallow compilations are still used to you can get quick language features on all tokens. The compilation is refreshed on save.</p>"},{"location":"hdl/hdl/#setting-a-compilation","title":"Setting a Compilation","text":""},{"location":"hdl/hdl/#setting-a-build-file","title":"Setting a build file","text":"<p>A build pattern can be set to glob for .f files, e.g. <code>**/*.f</code>. Then you can run the \"Select Build File\" Command from the hierarchy view or as a general command. The general LSP command is <code>setBuildFile(path: str)</code>.</p>"},{"location":"hdl/hdl/#setting-a-top-level","title":"Setting a top level","text":"<ul> <li> <p>The 'chip' icon at the top right of a file will scan the current file for valid top levels, and find all necessary files for a compilation.</p> </li> <li> <p></p> </li> </ul>"},{"location":"hdl/hdl/#hierarchy-view","title":"Hierarchy View","text":"<ul> <li>The Hierarchy View shows the elaborated tree, with declared types and resolved values to the right of the identifier.</li> </ul> <p>### Hierarchy Buttons (left to right)   - Clear Top Level   - Set Build File   - Toggle data- wires, registers, etc.   - Toggle objects defined behind macro usages.   - Toggle paramters- params, localparams, etc.   - Collapse all</p> <p>Buttons exist on each object to copy its hierarchical path.   An extra button exists on modules to go to the module definition, rather than the instantiation of that module.</p> <p>Clicking a symbol in the hierarchy view or modules view will open the instance in the file, as well as in the other view.</p> <ul> <li></li> </ul>"},{"location":"hdl/hdl/#modules-view","title":"Modules View","text":"<ul> <li> <p>The modules view shows the instances indexed by module, sorted by the number of instances with higher level objects closer to the top.</p> </li> <li> <p></p> </li> </ul>"},{"location":"hdl/hdl/#setting-a-scope","title":"Setting a scope","text":""},{"location":"hdl/hdl/#slang-select-scope-command","title":"<code>Slang: Select Scope</code> Command","text":"<p>This command pulls up a fuzzy finder where you can enter the hierarchical path.</p>"},{"location":"hdl/hdl/#terminal-links","title":"Terminal Links","text":"<p>Hierarchical paths are automatically recognized for vscode-integrated terminals, and will set the compilation and the instance. Even if the exact instance can't be found, it will eagerly open the instance until the names are invalid.</p>"},{"location":"hdl/hdl/#cone-tracing-experimental","title":"Cone Tracing (experimental)","text":"<p>This allows for drivers/loads tracing over the call hierarchy lsp route, since it's an analogous concept.</p>"},{"location":"hdl/hdl/#waveform-integration-experimental","title":"Waveform Integration (experimental)","text":"<ul> <li>This is currently only setup between Neovim and Surfer, through the WCP (waveform control protocol), which runs on JSON-RPC over TCP.</li> </ul> <p>### Editor Features   - open waveform file   - open signal in wave viewer   - open module in wave viewer</p> <p>### Wave Viewer Features   - open signal in hierarchy view / editor   - open driver/loads for signal</p> <ul> <li></li> </ul>"},{"location":"start/config/","title":"Configuration","text":"<p>The server is configurable through server.json files</p>"},{"location":"start/config/#configuration-files","title":"Configuration Files","text":"<p>The server uses a hierarchical configuration system, layering options in this order:</p> <ul> <li><code>~/.slang/server.json</code></li> <li><code>${workspaceFolder}/.slang/server.json</code> (should be on source control)</li> <li><code>${workspaceFolder}/.slang/local/server.json</code> (<code>.slang/local</code> should be ignored by source control)</li> </ul>"},{"location":"start/config/#config-options","title":"Config options","text":"<p>All configuration options are optional and have sensible defaults.</p>"},{"location":"start/config/#flags","title":"<code>flags</code>","text":"<p>Type: <code>string</code> Description: Flags to pass to slang Example: <code>\"--top=my_top_module --include-dir=./src\"</code></p>"},{"location":"start/config/#indexglobs","title":"<code>indexGlobs</code>","text":"<p>Type: <code>array of strings</code> Default: <code>[\"./.../*.sv*\"]</code> Description: SV Globs of what to index. Supports recursive patterns with <code>...</code> \\ Example:</p> <pre><code>{\n  \"indexGlobs\": [\"./src/.../*.sv\", \"./tb/.../*.sv\", \"./include/.../*.svh\"]\n}\n</code></pre>"},{"location":"start/config/#excludedirs","title":"<code>excludeDirs</code>","text":"<p>Type: <code>array of strings</code> Description: Directories to exclude from indexing Example:</p> <pre><code>{\n  \"excludeDirs\": [\"build\", \"temp\", \"old_code\"]\n}\n</code></pre>"},{"location":"start/config/#indexingthreads","title":"<code>indexingThreads</code>","text":"<p>Type: <code>integer</code> Default: <code>0</code> (auto-detect) Description: Thread count to use for indexing. When set to 0, automatically detects the optimal number of threads based on system capabilities.</p>"},{"location":"start/config/#parsingthreads","title":"<code>parsingThreads</code>","text":"<p>Type: <code>integer</code> Default: <code>8</code> Description: Thread count to use for parsing SystemVerilog files for compilations.</p>"},{"location":"start/config/#build","title":"<code>build</code>","text":"<p>Type: <code>string</code> (optional) Description: Build file to automatically open on start Example: <code>\"./build/compile.f\"</code></p>"},{"location":"start/config/#buildpattern","title":"<code>buildPattern</code>","text":"<p>Type: <code>string</code> (optional) Description: Build file pattern used to find the a .f file given a the name of a waveform file. (e.g. /tmp/{}.fst with builds/{}.f looks for build/foo.f to load the compilation). This is also used to look for .f files in the vscode client when selecting a .f file. Example: <code>\"builds/{}.f\"</code></p>"},{"location":"start/config/#wcpcommand","title":"<code>wcpCommand</code>","text":"<p>Type: <code>string</code> Description: Waveform viewer command where <code>{}</code> will be replaced with the WCP port Example: <code>\"surfer --wcp-initiate {}\"</code></p>"},{"location":"start/config/#example-configuration","title":"Example Configuration","text":"<pre><code>{\n  \"flags\": \"-f tools/slang/slang-server.f\",\n  \"indexGlobs\": [\"./src/**/*.sv\", \"./tb/**/*.sv\"],\n  \"excludeDirs\": [\"build\", \"obj_dir\"],\n  \"indexingThreads\": 4,\n  \"parsingThreads\": 8,\n  \"build\": \"./scripts/compile.f\",\n  \"wcpCommand\": \"surfer --wcp-initiate {}\"\n}\n</code></pre>"},{"location":"start/installing/","title":"Installing","text":""},{"location":"start/installing/#build-from-source","title":"Build from Source","text":"<pre><code># Clone the repository\ngit clone https://github.com/hudson-trading/slang-server.git\ncd slang-server\n\n# Pull dependencies\ngit submodule update --init --recursive\n\n# Build with cmake using a C++20 compliant compiler\ncmake -B build -DCMAKE_BUILD_TYPE=Release\ncmake --build build -j$(nproc)\n</code></pre>"},{"location":"start/installing/#pre-built-binaries","title":"Pre-built binaries","text":"<p>In the future there will be pre-built binaries released for common platforms. It's also planned to have the editor clients auto-install these, similar to what clangd and others do.</p>"},{"location":"start/installing/#neovim","title":"Neovim","text":"<p>There are many ways to configure a language server in Neovim. One can use the nvim API directly. Plugins like nvim-lspconfig and mason make managing language servers easier but slang-server has not yet been added to those projects. If you happen to use lazy.nvim you can configure the language server by adding or ammending <code>~/.config/nvim/lua/plugins/lsp/nvim-lspconfig.lua</code> with this:</p> <pre><code>return {\n  \"neovim/nvim-lspconfig\",\n  opts = {\n    setup = {\n      slang_server = function(_, opts)\n        local configs = require(\"lspconfig.configs\")\n        local util = require(\"lspconfig.util\")\n\n        if not configs.slang_server then\n          configs.slang_server = {\n            default_config = {\n              cmd = {\n                \"slang-server\",\n              },\n              filetypes = {\n                \"systemverilog\",\n                \"verilog\",\n              },\n              single_file_support = true,\n              root_dir = function(fname)\n                return util.root_pattern(\".slang-server.json\")(fname)\n                  or vim.fs.dirname(vim.fs.find(\".git\", { path = fname, upward = true })[1])\n              end,\n            },\n          }\n        end\n      end,\n    },\n    servers = {\n      slang_server = {\n        enabled = true,\n        mason = false,\n      },\n    },\n  },\n}\n</code></pre> <p>Neovim natively handles the LSP. No additional plugin is required to use Slang Server for standard LSP actions (e.g. Go to Definition, however the slang-server.nvim plugin is provided to enable use of the features which extend the LSP (e.g. hierachical compilation).</p>"},{"location":"start/installing/#vscode","title":"Vscode","text":"<p>Extension will be released soon</p>"}]}