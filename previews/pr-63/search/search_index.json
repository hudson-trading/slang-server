{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p><code>slang-server</code> is a high-performance Language Server Protocol (LSP) implementation for SystemVerilog, built on top of the Slang SystemVerilog frontend.</p>"},{"location":"#overview","title":"Overview","text":"<p>slang-server provides comprehensive SystemVerilog language support for modern editors and IDEs, including:</p> <ul> <li>Real-time diagnostics and linting</li> <li>Code completion and IntelliSense</li> <li>Go-to definition and Hover Info</li> <li>Symbol search and workspace indexing</li> <li>Hardware-specific language extensions</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":"<p>Check out the installation guide and learn how to configure your editor.</p>"},{"location":"#project-status","title":"Project Status","text":"<p>slang-server is actively developed by the hardware team at Hudson River Trading and welcomes community contributions. The project aims to be the most comprehensive and performant SystemVerilog language server.</p>"},{"location":"#support-contributing","title":"Support &amp; Contributing","text":"<ul> <li>Bug Reports: Open an issue on GitHub</li> <li>Contributing: Pull requests are welcome! See our contributing guidelines.</li> </ul>"},{"location":"#license","title":"License","text":"<p>slang-server is licensed under the MIT License. See the full license for details.</p>"},{"location":"design/indexing/","title":"Workspace Indexing","text":"<p>slang-server's indexing system provides fast symbol lookup and navigation across large SystemVerilog codebases by building and maintaining an index of top level symbols.</p>"},{"location":"design/indexing/#how-it-works","title":"How it works","text":"<p>The Indexer indexes based on these config options on startup:</p> <ul> <li><code>indexGlobs</code> (default: <code>\"./.../*.sv*\"</code>)</li> <li><code>excludeDirs</code> (default: <code>[]</code>)</li> </ul> <p>It uses multithreading to rapidly index your repo. Crawling a file system actually often takes longer than parsing, so make sure these are as specific as possible.</p> <p>In each syntax tree parsed, it indexes the top level symbols like moduldes, packages, etc. If no top level symbols were found, it'll instead index the macros defined in that file.</p> <p>In the future, this will also index the referenced top level symbols to enable the go-to references feature.</p>"},{"location":"design/shallow/","title":"Shallow Compilation","text":"<p>In order to provide real time diagnostics and symbols, the server makes use of the concept of a shallow compilation, where directly referenced top level symbols in the current document are loaded for use in a slang compilation.</p> <p>In software languages this is typically standard- you can compile just one cpp file for example, and forward declare other symbols that you use. This isn't really a thing for HDLs, where a full design is almost always assumed. Parts of Slang can be tweaked to essentially get this functionality.</p>"},{"location":"design/shallow/#limitations","title":"Limitations","text":"<p>Hierarchical references can go down or up more than one layer, in which case some symbols may not load. It would be nice to continue adding the relevant syntax trees to get all symbols in the current document, rather than just loading directly referenced symbols. Upward references will always be a blind spot for the language server, and are generally not considered a good practice.</p>"},{"location":"design/shallow/#allgeneratebranches","title":"AllGenerateBranches","text":"<p>This compilation flag is used in shallow compilations to get symbols and diagnostics on all generate branches. This process can definitely be improved; for example certain diags are marked as invalid for shallow compilation, and that's tricky since some may have been missed, and ideally the system would never go down the path where it's publishing those diags.</p> <p>A related issue is the case of ifdef branches. Making an AllIfdefBranches flag would certainly cause chaos, and perhaps the best way of dealing with this is to just do syntax lookups in the untaken branches to provide symbols.</p>"},{"location":"design/shallow/#interface-port-parameter-asserts","title":"Interface Port Parameter Asserts","text":"<p>It's a common pattern to declare an input/output interface with a datatype, however SystemVerilog doesn't let you restrict the params of these interface ports, and people instead rely on asserts. Ideally slang could pick up on these asserts and fill in the correct dtype for these. Even more ideally, these constraints would be in the language itself. Either implementation would provide the user with more accurate info when doing hierarhical completions.</p>"},{"location":"design/shallow/#single-unit","title":"Single Unit","text":"<p>The slang <code>--single-unit</code> causes all parsed files to essentially be squashed together, which has the effect of syntax trees inheriting preprocessor macros and defines.</p> <p>Actually parsing the files this way in the language server would slow down the server considerably. So repos that use this will see errors for symbols - typically macros - that are not explicitly included.</p> <p>Support for this could be added in the future by feeding the indexed macros to the preprocessor if it can't find the macro in its current working set.</p>"},{"location":"features/completions/","title":"Completion Examples","text":""},{"location":"features/features/","title":"Feature Support","text":"<p>slang-server provides comprehensive Language Server Protocol (LSP) support for SystemVerilog, offering modern IDE features that significantly enhance development productivity.</p>"},{"location":"features/features/#symbol-specific-feature-support","title":"Symbol-Specific Feature Support","text":"Symbol Type GoTo Hover Completion Notes Modules \u2705 \u2705 \u2705 Interfaces \u2705 \u2705 \u2705 Classes \ud83d\udfe1 \ud83d\udfe1 \ud83d\udfe1 Functions/Tasks \u2705 \u2705 \ud83d\udfe1 Completions can be improved with signatures Scope Variables \u2705 \u2705 \u2705 Ports \u2705 \u2705 \u274c Completions planned for ports on instances Parameters \u2705 \u2705 \u274c Completions planned for params on instances Typedefs \u2705 \u2705 \u26aa Custom type definitions Enums \u2705 \u2705 \u26aa Enumeration values Packages \u2705 \u2705 \u2705 Completions for package members Wildcard Imports \u2705 \u2705 \u2705 Completions for imported members Macros \ud83d\udfe1 \u2705 \u2705 Indexed macro completions System Tasks \u26aa \u274c \u274c Planned &lt;!-- Constraints \ud83d\udfe1 \u274c \ud83d\udfe1 &lt;!-- Covergroups \u2705 \u2705 \ud83d\udfe1 Assertions \u2705 \u2705 \ud83d\udfe1 SVA property support &lt;!-- DPI Functions \ud83d\udfe1 \u274c \u2705"},{"location":"features/hovers/","title":"Hover Examples","text":""},{"location":"features/planned/","title":"Planned Features","text":""},{"location":"features/planned/#find-references","title":"Find references","text":"<p>This feature will likely be implemented in this order:</p> <ul> <li>top level symbols like macros, modules, packages, and interfaces</li> <li>scope members</li> <li>struct members</li> </ul>"},{"location":"features/planned/#semantic-token-highlighting","title":"Semantic Token Highlighting","text":"<p>This will provide additional coloring for variable names, distinguisihing between wires, registers, and parameters.</p> <p>For classes/functions it will distinguish betweeen instance variables, function args and locals.</p>"},{"location":"features/planned/#inlay-hints","title":"Inlay Hints","text":"<p>Ports - Show the type of ports in instances</p> <p>Params - Show the resolved value of parameters</p> <p>Signals - Show the resolved type of wires and registers, and show the value when a waveform is connected</p> <p>Macros/Functions - Show the positional argument names</p> <p>Wildcard Ports - Show which signals are passed through</p> <p>Wildcard Imports - Show which symbols are used from the import</p>"},{"location":"features/planned/#formatter","title":"Formatter","text":"<p>This one is pretty self explanatory, but it will live in the slang repo and also be shipped as a standalone binary. In order to make formatting nice for things like hovers and completions, basic formatting functions already exist in this repo, but not a full formatter. This includes things like squashing white spaces to condense hovers/completion types, and left aligning blocks of text for hovers and completion docs.</p>"},{"location":"hdl/api/","title":"External Tools","text":"<p>There have been requests to integrate external tools with the slang language server. While integrations have only been made with waveform viewers so far, these are guidlines for how one would go about adding more integrations.</p> <p>Integrations are typically working with a slang compilation (elaborated design), since these are an hdl-specific construct and outside the scope of the LSP.</p> <p>In general it's preferred for the <code>slang-server</code> to initiate the handshake, since a user will likely always start with their editor, and move to more advanced tools when necessary.</p>"},{"location":"hdl/api/#vscode-only-integrations","title":"Vscode-only Integrations","text":"<p>Vscode apis can easily be exposed via hidden commands that aren't shown to the user. See <code>ProjectComponent.ts</code> for examples of some commands. Some new routes may need to be added to the server-client interface as well in <code>SlangInterface.ts</code></p> <p>There should be an api exposed to subscribe to changes to which filelist is set, as well as when updated slang compilations are available.</p>"},{"location":"hdl/api/#slang-cpp-integrations","title":"Slang Cpp Integrations","text":"<p>Similarly, it would be ideal to subscribe to a compilation and receive updates in cpp. However to get the full detail, the server should share a non-owning reference to the compilation over shared memory. This would need to be implemented.</p>"},{"location":"hdl/api/#other-integrations","title":"Other Integrations","text":"<p>One can look to the Surfer wcp work for implementing an editor-agnostic and implementation-language-agnostic integration over JsonRPC.</p>"},{"location":"hdl/hdl/","title":"Hardware Language Features","text":"<p>When a compilation is set, a full hierarchy will be elaborated in conjunction with the shallow compilations per file, which are still used to get quick language features on all tokens. The compilation is refreshed on save.</p> <p>See the Vscode Docs</p> <p>See the Neovim Docs</p> <p></p>"},{"location":"hdl/neovim/","title":"Hardware Language Features - Neovim","text":"<p>All features listed here require the Neovim plugin.  See the installation guide for how to get started. Once installed the <code>SlangServer</code> command will provide a number of subcommands outlined below.</p>"},{"location":"hdl/neovim/#setting-a-compilation","title":"Setting a Compilation","text":""},{"location":"hdl/neovim/#setting-a-build-file","title":"Setting a build file","text":"<pre><code>:SlangServer setBuildFile BUILDFILE\n</code></pre> <p>This uses the file located at `BUILDFILE`` to compile a full hierarchy and is required for some of the commands below.</p>"},{"location":"hdl/neovim/#setting-a-top-level","title":"Setting a top level","text":"<pre><code>:SlangServer setTopLevel [TOPFILE]\n</code></pre> <p>This uses a file to run a compilation using the top-most module in the provided file.  If <code>TOPFILE</code> is not provided the file from the current buffer will be used.</p>"},{"location":"hdl/neovim/#hierarchyview","title":"HierarchyView","text":"<pre><code>:SlangServer hierarchy [SCOPE]\n</code></pre> <p>This will open the hierarchy view and, if <code>SCOPE</code> is provided, expand the view to that scope.</p> <p></p>"},{"location":"hdl/neovim/#cone-tracing-experimental","title":"Cone Tracing (experimental)","text":"<p><pre><code>:lua vim.lsp.buf.incoming_calls()\n</code></pre> <pre><code>:lua vim.lsp.buf.outgoing_calls()\n</code></pre></p> <p>This allows for drivers/loads tracing over the call hierarchy lsp route, since it's an analogous concept.  Tracing incoming calls yields drivers of a given signal and outgoing calls yields loads or things the signal drives. Calling one of these functions will trace the signal currently under the cursor. If there is more than one instance of the signal then first a list of instances will be presented. After an instance is selected (or if there is only one instance) a list of drivers or loads will be presented.</p>"},{"location":"hdl/neovim/#waveform-integration-experimental","title":"Waveform Integration (experimental)","text":"<p>This is currently only setup between Neovim and Surfer, through the WCP (waveform control protocol), which runs on JSON-RPC over TCP.</p>"},{"location":"hdl/neovim/#editor-features","title":"Editor Features","text":""},{"location":"hdl/neovim/#open-waveform-file","title":"Open Waveform File","text":"<pre><code>:SlangServer openWaveform WAVEFILE\n</code></pre> <p>This opens the waveform file (e.g. VCD or FST) indicated by <code>WAVEFILE</code>. If there is no currently active WCP session a new waveform viewer will be launched using the command provided in the <code>wcpCommand</code> config field. By default this is Surfer. If a WCP session already exists, the new waveform file will be loaded. Additionally, if a <code>buildPattern</code> config field is provided, the build file which corresponds to the current wave file will be used to produce a compilation. E.g. given a wave file of <code>/some/dir/foo.fst</code> and a <code>buildPattern</code> of <code>/some/other/dir/{}.f</code> and compilation will be made using <code>/some/other/dir/foo.f</code>.</p>"},{"location":"hdl/neovim/#add-item","title":"Add Item","text":"<pre><code>:SlangServer addToWaves [RECURSIVE]\n</code></pre> <p>Adds the signal, module, interface or other scope currently under the cursor to the waveform viewer. If <code>RECURSIVE</code> is provided and is <code>true</code> and the item is a scope it will be added recursively. If more than one instance of the item exists, a list of instances will be provided to choose from.</p>"},{"location":"hdl/neovim/#wave-viewer-features","title":"Wave Viewer Features","text":"<ul> <li>Goto Definition</li> <li>Add Drivers</li> <li>Add Loads</li> </ul>"},{"location":"hdl/vscode/","title":"Hardware Language Features - Vscode","text":""},{"location":"hdl/vscode/#setting-a-compilation","title":"Setting a Compilation","text":""},{"location":"hdl/vscode/#setting-a-build-file","title":"Setting a build file","text":"<p>A build pattern can be set to glob for .f files, e.g. <code>**/*.f</code>. Then you can run the \"Select Build File\" Command from the hierarchy view or as a general command. The general LSP command is <code>setBuildFile(path: str)</code>.</p>"},{"location":"hdl/vscode/#setting-a-top-level","title":"Setting a top level","text":"<p>The 'chip' icon at the top right of a file will scan the current file for valid top levels, and find all necessary files for a compilation.</p> <p></p>"},{"location":"hdl/vscode/#hierarchy-view","title":"Hierarchy View","text":"<p>The Hierarchy View shows the elaborated tree, with declared types and resolved values to the right of the identifier.</p> <p>Hierarchy Buttons (left to right): - Clear Top Level - Set Build File - Toggle data- wires, registers, etc. - Toggle objects defined behind macro usages. - Toggle paramters- params, localparams, etc. - Collapse all</p> <p>Buttons exist on each object to copy its hierarchical path. An extra button exists on modules to go to the module definition, rather than the instantiation of that module.</p> <p>Clicking a symbol in the hierarchy view or modules view will open the instance in the file, as well as in the other view.</p> <p></p>"},{"location":"hdl/vscode/#modules-view","title":"Modules View","text":"<p>The modules view shows the instances indexed by module, sorted by the number of instances with higher level objects closer to the top.</p> <p></p>"},{"location":"hdl/vscode/#setting-a-scope","title":"Setting a scope","text":""},{"location":"hdl/vscode/#slang-select-scope-command","title":"<code>Slang: Select Scope</code> Command","text":"<p>This command pulls up a fuzzy finder where you can enter the hierarchical path.</p>"},{"location":"hdl/vscode/#terminal-links","title":"Terminal Links","text":"<p>Hierarchical paths are automatically recognized for vscode-integrated terminals, and will set the compilation and the instance. Even if the exact instance can't be found, it will eagerly open the instance until the names are invalid.</p> <p></p>"},{"location":"start/config/","title":"Configuration","text":"<p>The server is configurable through server.json files</p>"},{"location":"start/config/#configuration-files","title":"Configuration Files","text":"<p>The server uses a hierarchical configuration system, layering options in this order:</p> <ul> <li><code>~/.slang/server.json</code></li> <li><code>${workspaceFolder}/.slang/server.json</code> (should be on source control)</li> <li><code>${workspaceFolder}/.slang/local/server.json</code> (<code>.slang/local</code> should be ignored by source control)</li> </ul> <p>A set config option overrides the existing value in the previous config, except for lists, which are appended.</p>"},{"location":"start/config/#config-options","title":"Config options","text":"<p>All configuration options are optional and have sensible defaults. In Vscode, the configuration files are self-documenting via a generated json schema, meaning that there are completions and hovers for the server.json files.</p>"},{"location":"start/config/#indexglobs","title":"<code>indexGlobs</code>","text":"<p>Configuring this and excludeDirs are highly recommended, as narrowing these can dramatically reduce the indexing time. Crawling a directory can actually take more time than actually indexing the files, so avoiding build dirs and software dirs to reduce that time. If there's rewritten or generated verilog in build dirs that get indexed, it can slow down the language server and make features like gotos and completions inaccurate.</p> <p>Type: <code>array of strings</code></p> <p>Default: <code>[\"./.../*.sv*\"]</code></p> <p>Description: SV Globs of what to index. Supports recursive patterns with <code>...</code> \\</p> <p>Example:</p> <pre><code>{\n  \"indexGlobs\": [\"./src/.../*.sv\", \"./tb/.../*.sv\", \"./include/.../*.svh\"]\n}\n</code></pre>"},{"location":"start/config/#excludedirs","title":"<code>excludeDirs</code>","text":"<p>Type: <code>array of strings</code></p> <p>Description: Directories to exclude from indexing</p> <p>Example:</p> <pre><code>{\n  \"excludeDirs\": [\"build\", \"temp\", \"old_code\"]\n}\n</code></pre>"},{"location":"start/config/#flags","title":"<code>flags</code>","text":"<p>It's recommended to keep your slang flags in a flag file, that way it can be shared by both CI and the language server. Another nice setup is having slang.f contain your CI flags, then have slang-server.f include that file (via <code>-f path/to/slang.f</code>), then add more warnings in <code>slang-server.f</code>. This way more pedantic checks will show as yellow underlines in your editor.</p> <p>Type: <code>string</code></p> <p>Description: Flags to pass to slang</p> <p>Example: <code>\"-f path/to/slang_flags.f</code></p>"},{"location":"start/config/#indexingthreads","title":"<code>indexingThreads</code>","text":"<p>Type: <code>integer</code></p> <p>Default: <code>0</code> (auto-detect)</p> <p>Description: Thread count to use for indexing. When set to 0, automatically detects the optimal number of threads based on system capabilities.</p>"},{"location":"start/config/#parsingthreads","title":"<code>parsingThreads</code>","text":"<p>Type: <code>integer</code></p> <p>Default: <code>8</code></p> <p>Description: Thread count to use for parsing SystemVerilog files for compilations.</p>"},{"location":"start/config/#build","title":"<code>build</code>","text":"<p>Type: <code>string</code> (optional)</p> <p>Description: Build file to automatically open on start</p> <p>Example: <code>\"./build/compile.f\"</code></p>"},{"location":"start/config/#buildpattern","title":"<code>buildPattern</code>","text":"<p>Type: <code>string</code> (optional)</p> <p>Description: Build file pattern used to find the a .f file given a the name of a waveform file. (e.g. /tmp/{}.fst with builds/{}.f looks for build/foo.f to load the compilation). This is also used to look for .f files in the vscode client when selecting a .f file.</p> <p>Example: <code>\"builds/{}.f\"</code></p>"},{"location":"start/config/#wcpcommand","title":"<code>wcpCommand</code>","text":"<p>Type: <code>string</code></p> <p>Description: Waveform viewer command where <code>{}</code> will be replaced with the WCP port</p> <p>Example: <code>\"surfer --wcp-initiate {}\"</code></p>"},{"location":"start/config/#example-configuration","title":"Example Configuration","text":"<pre><code>{\n  \"flags\": \"-f tools/slang/slang-server.f\",\n  \"indexGlobs\": [\"./src/**/*.sv\", \"./tb/**/*.sv\"],\n  \"excludeDirs\": [\"build\", \"obj_dir\"],\n  \"indexingThreads\": 4,\n  \"parsingThreads\": 8,\n  \"build\": \"./scripts/compile.f\",\n  \"wcpCommand\": \"surfer --wcp-initiate {}\"\n}\n</code></pre>"},{"location":"start/installing/","title":"Installing","text":""},{"location":"start/installing/#build-from-source","title":"Build from Source","text":"<pre><code># Clone the repository\ngit clone https://github.com/hudson-trading/slang-server.git\ncd slang-server\n\n# Pull dependencies (slang and reflect-cpp)\ngit submodule update --init --recursive\n\n# Build with cmake using a C++20 compliant compiler\ncmake -B build -DCMAKE_BUILD_TYPE=Release\ncmake --build build -j --target slang_server\n</code></pre> <p>In the future there will be pre-built binaries released for common platforms. The editor clients will auto-install these, similar to what clangd and others do.</p>"},{"location":"start/installing/#vscode","title":"Vscode","text":"<p>Install the extension here, then set <code>slang.path</code> to the slang-server binary. (at <code>build/bin/slang-server</code>)</p> <p>See VSCode Options</p> <p>An OpenVSX release is coming soon, but in the meantime it's possible to run <code>cd clients/vscode &amp;&amp; pnpm install &amp;&amp; pnpm run prepublishOnly</code> to create an installable vsix. OpenVSX is used by the Vscode forks.</p>"},{"location":"start/installing/#neovim","title":"Neovim","text":"<p>[!NOTE] Once Slang Server is more actively used (you can help by starring the project!), it will be added to nvim-lspconfig and mason.nvim and no additional configuration will be required. Until then, follow one of the methods below to manually add the server configuration.</p> <p>There are many ways to configure a language server in Neovim.</p> <p>For newer versions of Neovim (\u2265 v0.11), the new vim.lsp API is the preferred, simpler way to configure language servers: <pre><code>vim.lsp.config(\"slang-server\", {\n  cmd = \"slang-server\",\n  root_markers = { \".git\", \".slang\" },\n  filetypes = {\n    \"systemverilog\",\n    \"verilog\",\n  },\n})\n\nvim.lsp.enable(\"slang-server\")\n</code></pre></p> <p>For older versions of Neovim (&lt; v0.11) with <code>nvim-lspconfig</code>, the server can be configured with: <pre><code>local configs = require(\"lspconfig.configs\")\nlocal util = require(\"lspconfig.util\")\n\nif not configs.slang_server then\n  configs.slang_server = {\n    default_config = {\n      cmd = {\n        \"slang-server\",\n      },\n      filetypes = {\n        \"systemverilog\",\n        \"verilog\",\n      },\n      single_file_support = true,\n      root_dir = function(fname)\n        return util.root_pattern(\".git\", \".slang\")(fname)\n      end,\n    },\n  }\nend\n</code></pre></p> <p>For users of lazy.nvim, the above could be added to their <code>nvim-lspconfig</code> spec at <code>~/.config/nvim/lua/plugins/nvim-lspconfig.lua</code> like this: <pre><code>return {\n  \"neovim/nvim-lspconfig\",\n  opts = {\n    setup = {\n      slang_server = function(_, opts)\n        local configs = require(\"lspconfig.configs\")\n        local util = require(\"lspconfig.util\")\n\n        if not configs.slang_server then\n          configs.slang_server = {\n            default_config = {\n              cmd = {\n                \"slang-server\",\n              },\n              filetypes = {\n                \"systemverilog\",\n                \"verilog\",\n              },\n              single_file_support = true,\n              root_dir = function(fname)\n                return util.root_pattern(\".git\", \".slang\")(fname)\n              end,\n            },\n          }\n        end\n      end,\n    },\n    servers = {\n      slang_server = {\n        enabled = true,\n        mason = false,\n      },\n    },\n  },\n}\n</code></pre></p> <p>Neovim natively handles the LSP. No additional plugin is required to use Slang Server for standard LSP actions (e.g. Go to Definition.</p> <p>However, a plugin is provided to enable use of some enhanced client-side features which extend the LSP (e.g. hierachical compilation). The plugin can be found in <code>clients/neovim/</code> and is also mirrored in slang-server.nvim for ease of use with Neovim plugin managers.</p>"},{"location":"start/installing/#other-editors","title":"Other editors","text":"<p>Most modern editors can at least point to a language server binary for specific file types, which provides standard LSP features, but not HDL specific frontend features like the hierarchy view.</p> <p>If the editor also allows for executing LSP commands, HDL features like setting a compilation should be available, although the process may not be as smooth.</p>"}]}