
timeunit 1ns / 1ps;

timeprecision 1ps;



(* foo = 1 *) package static p;
                             ^ Sym p : PackageDeclaration

    timeunit 1ns;

    parameter int x = 1;
                  ^ Sym x : Declarator

    parameter type y_t = logic[x:0];
                   ^^^ Sym y_t : TypeAssignment
                               ^ Ref -> `parameter int x = 1`

    parameter int x2 = x + 1;
                  ^^ Sym x2 : Declarator
                       ^ Ref -> `parameter int x = 1`

    parameter type y = logic[x:0];
                   ^ Sym y : TypeAssignment
                             ^ Ref -> `parameter int x = 1`

    parameter type y2 = logic[x2:0];
                   ^^ Sym y2 : TypeAssignment
                              ^^ Ref -> `parameter int x2 = x + 1`

    program; endprogram

    export *::*;

endpackage



package pkg1;
        ^^^^ Sym pkg1 : PackageDeclaration

    typedef struct packed {

        logic [7:0] data;

        logic valid;

    } packet_t;
      ^^^^^^^^ Sym packet_t : TypedefDeclaration

endpackage



package pkg2;
        ^^^^ Sym pkg2 : PackageDeclaration

    import pkg1::packet_t;
           ^^^^ Ref -> `package pkg1;`
                 ^^^^^^^^ Ref -> `// In pkg1`\n\\n\---\n\\n\`typedef struct packed {\n\    logic [7:0] data;\n\    logic valid;\n\} packet_t;`

    export pkg1::packet_t;
           ^^^^ Ref -> `package pkg1;`
                 ^^^^^^^^ Ref -> `// In pkg1`\n\\n\---\n\\n\`typedef struct packed {\n\    logic [7:0] data;\n\    logic valid;\n\} packet_t;`

endpackage



module automatic m1 import p::*; #(int i = 1)
                 ^^ Sym m1 : ModuleDeclaration
                           ^ Ref -> `package static p;`
                                       ^ Sym i : Declarator

    (a, b, , .c({a, b[0]}));
     ^ Sym a : PortReference
        ^ Sym b : PortReference

    input a;
          ^ Sym a : Declarator

    output [1:0] b;
                 ^ Sym b : Declarator

    localparam int c = p::x;
                   ^ Sym c : Declarator
                       ^ Ref -> `package static p;`
                          ^ Ref -> `// In p`\n\\n\---\n\\n\`parameter int x = 1`

    localparam p::y d = {1'b0, 1'b1};
               ^ Ref -> `package static p;`
                  ^ Ref -> `// In p`\n\\n\---\n\\n\`parameter type y = logic[x:0]`
                    ^ Sym d : Declarator

endmodule



module m2 #(
       ^^ Sym m2 : ModuleDeclaration

    parameter i = 1,
              ^ Sym i : Declarator

    localparam j = i,
               ^ Sym j : Declarator
                   ^ Ref -> `parameter i = 1`

    parameter type x_t = bit

)

    (input int a[], (* bar = "asdf" *) output logic b = 1, ref c,
               ^ Sym a : Declarator
                                                    ^ Sym b : Declarator
                                                               ^ Sym c : Declarator

    input p::y2 d2,
          ^ Ref -> `package static p;`
             ^^ Ref -> `// In p`\n\\n\---\n\\n\`parameter type y2 = logic[x2:0]`
                ^^ Sym d2 : Declarator

     interface.mod d, .e());
                   ^ Sym d : Declarator
                       ^ Sym e : ExplicitAnsiPort

endmodule



extern interface I(input a, output b);
                 ^ Ref -> `interface I(.*);`
                         ^ Sym a : Declarator
                                   ^ Sym b : Declarator



interface I(.*);
          ^ Sym I : InterfaceDeclaration

    modport mod(input a);
            ^^^ Sym mod : ModportDeclaration
                      ^ Sym a : ModportSimplePortList

endinterface



extern macromodule m3;
                   ^^ Ref -> `macromodule m3;`



macromodule m3;
            ^^ Sym m3 : ModuleDeclaration

    wire b;
         ^ Sym b : Declarator

    logic c;
          ^ Sym c : Declarator

    I d(.a(), .b());
    ^ Ref -> `interface I(.*);`
      ^ Sym d : HierarchicalInstance
         ^ Ref -> `// In I`\n\\n\---\n\\n\`input a`
               ^ Ref -> `// In I`\n\\n\---\n\\n\`output b`



    typedef p::y_t y_t;
            ^ Ref -> `package static p;`
               ^^^ Ref -> `// In p`\n\\n\---\n\\n\`parameter type y_t = logic[x:0]`
                   ^^^ Sym y_t : TypedefDeclaration



    m2 #(
    ^^ Ref -> `module m2 #(\n\    parameter i = 1,\n\    localparam j = i,\n\    parameter type x_t = bit\n\)\n\    (input int a[], (* bar = "asdf" *) output logic b = 1, ref c,\n\    input p::y2 d2,\n\     interface.mod d, .e());`

        .x_t(y_t)
         ^^^ Ref -> `// In m2`\n\\n\---\n\\n\`parameter type x_t = bit`
             ^^^ Ref -> `typedef p::y_t y_t;`

    ) m (, b, c, d, );
      ^ Sym m : HierarchicalInstance
           ^ Ref -> `wire b;`
              ^ Ref -> `logic c;`
                 ^ Ref -> `I d(.a(), .b());`





    typedef p::y2 y2;
            ^ Ref -> `package static p;`
               ^^ Ref -> `// In p`\n\\n\---\n\\n\`parameter type y2 = logic[x2:0]`
                  ^^ Sym y2 : TypedefDeclaration



    m2 #(
    ^^ Ref -> `module m2 #(\n\    parameter i = 1,\n\    localparam j = i,\n\    parameter type x_t = bit\n\)\n\    (input int a[], (* bar = "asdf" *) output logic b = 1, ref c,\n\    input p::y2 d2,\n\     interface.mod d, .e());`

        .i(1),
         ^ Ref -> `// In m2`\n\\n\---\n\\n\`parameter i = 1`

        .x_t(y2)
         ^^^ Ref -> `// In m2`\n\\n\---\n\\n\`parameter type x_t = bit`
             ^^ Ref -> `typedef p::y2 y2;`

    ) m2_inst (
      ^^^^^^^ Sym m2_inst : HierarchicalInstance

        .a({1, 2}),
         ^ Ref -> `// In m2`\n\\n\---\n\\n\`input int a[]`

        .b(b),
         ^ Ref -> `// In m2`\n\\n\---\n\\n\`(* bar = "asdf" *) output logic b = 1`
           ^ Ref -> `wire b;`

        .c(),
         ^ Ref -> `// In m2`\n\\n\---\n\\n\`ref c`

        .d(d),
         ^ Ref -> `// In m2`\n\\n\---\n\\n\`interface.mod d`
           ^ Ref -> `I d(.a(), .b());`

        .e()
         ^ Ref -> `// In m2`\n\\n\---\n\\n\`.e()`

    );



    $info("Hello %s", "world");



    wor [1:0] w = 1;
              ^ Sym w : Declarator

    assign (supply0, weak1) #(1:0:1, 2:1:0) w = 2;
                                            ^ Ref -> `wor [1:0] w = 1;`



    wor u,v;
        ^ Sym u : Declarator
          ^ Sym v : Declarator

    alias {u,v} = w;
           ^ Ref -> `wor u,v;`
             ^ Ref -> `wor u,v;`
                  ^ Ref -> `wor [1:0] w = 1;`



    logic f, z;
          ^ Sym f : Declarator
             ^ Sym z : Declarator

    event ev;
          ^^ Sym ev : Declarator

    initial begin

        repeat (3) @(negedge b) f = #2 1;
                             ^ Ref -> `wire b;`
                                ^ Ref -> `logic f, z;`

        wait (f) ++f;
              ^ Ref -> `logic f, z;`
                   ^ Ref -> `logic f, z;`

        wait fork;

        wait_order (m3.ev) f++;
                       ^^ Ref -> `event ev;`
                           ^ Ref -> `logic f, z;`



        fork : fkb
               ^^^ Sym fkb : ParallelBlockStatement

            static int i = 1;
                       ^ Sym i : Declarator

            disable fork;

        join_none



        disable m3.foo;
                   ^^^ Ref -> `begin : foo\n\end : foo`



        assign z = 1;
               ^ Ref -> `logic f, z;`

        deassign z;
                 ^ Ref -> `logic f, z;`



        if (1) begin end else begin end



        unique0 casex (w)
                       ^ Ref -> `wor [1:0] w = 1;`

            0, 1: ;

            default ;

        endcase



        case (w) inside
              ^ Ref -> `wor [1:0] w = 1;`

            [0: 3]: ;

        endcase

    end



    always_ff @(posedge b iff f == 1) begin
                        ^ Ref -> `wire b;`
                              ^ Ref -> `logic f, z;`

        forever break;

        repeat (f + 2) continue;
                ^ Ref -> `logic f, z;`

        while (1)

            ;

        for (int i = 0, j = i; i < 10; i += 2, j += i) begin end
                 ^ Sym i : Declarator
                        ^ Sym j : Declarator
                            ^ Ref -> `int i = 0`
                               ^ Ref -> `int i = 0`
                                       ^ Ref -> `int i = 0`
                                               ^ Ref -> `j = i`
                                                    ^ Ref -> `int i = 0`

        foreach (w[q]) begin end
                 ^ Ref -> `// In m3`\n\\n\---\n\\n\`wor [1:0] w = 1;`

    end



    always @* begin : foo
                      ^^^ Sym foo : SequentialBlockStatement

    end : foo



    always_comb begin

        typedef union tagged {

            void Invalid;

            int Valid;

        } VInt;
          ^^^^ Sym VInt : TypedefDeclaration



        typedef union tagged {

            struct {

                bit [4:0] reg1, reg2, regd;

            } Add;

            union tagged {

                bit [9:0] JmpU;

                struct {

                    bit [1:0] cc;

                    bit [9:0] addr;

                } JmpC;

            } Jmp;

        } Instr;
          ^^^^^ Sym Instr : TypedefDeclaration



        VInt v;
        ^^^^ Ref -> `typedef union tagged {\n\    void Invalid;\n\    int Valid;\n\} VInt;`
             ^ Sym v : Declarator

        Instr instr;
        ^^^^^ Ref -> `typedef union tagged {\n\    struct {\n\        bit [4:0] reg1, reg2, regd;\n\    } Add;\n\    union tagged {\n\        bit [9:0] JmpU;\n\        struct {\n\            bit [1:0] cc;\n\            bit [9:0] addr;\n\        } JmpC;\n\    } Jmp;\n\} Instr;`
              ^^^^^ Sym instr : Declarator

        automatic int rf[] = new [3];
                      ^^ Sym rf : Declarator

        static longint pc = 'x;
                       ^^ Sym pc : Declarator



        case (v) matches
              ^ Ref -> `VInt v;`

            tagged Invalid &&& ~w : $display ("v is Invalid");
                                ^ Ref -> `// In m3`\n\\n\---\n\\n\`wor [1:0] w = 1;`

            tagged Valid .n : $display ("v is Valid with value %d", n);
                          ^ Sym n : VariablePattern
                                                                    ^ Ref -> `.n`

        endcase



        case (instr) matches
              ^^^^^ Ref -> `Instr instr;`

            tagged Add .s: case (s) matches
                        ^ Sym s : VariablePattern
                                 ^ Ref -> `.s`

                            '{.*, .*, 0} : ; // no op

                            '{.r1, .r2, .rd} : rf[rd] = rf[r1] + rf[r2];
                               ^^ Sym r1 : VariablePattern
                                    ^^ Sym r2 : VariablePattern
                                         ^^ Sym rd : VariablePattern
                                               ^^ Ref -> `// In m3`\n\\n\---\n\\n\`automatic int rf[] = new [3];`
                                                  ^^ Ref -> `.rd`
                                                        ^^ Ref -> `// In m3`\n\\n\---\n\\n\`automatic int rf[] = new [3];`
                                                           ^^ Ref -> `.r1`
                                                                 ^^ Ref -> `// In m3`\n\\n\---\n\\n\`automatic int rf[] = new [3];`
                                                                    ^^ Ref -> `.r2`

                          endcase

            tagged Jmp .j: case (j) matches
                        ^ Sym j : VariablePattern
                                 ^ Ref -> `.j`

                            tagged JmpU .a : pc = pc + a;
                                         ^ Sym a : VariablePattern
                                             ^^ Ref -> `// In m3`\n\\n\---\n\\n\`static longint pc = 'x;`
                                                  ^^ Ref -> `// In m3`\n\\n\---\n\\n\`static longint pc = 'x;`
                                                       ^ Ref -> `.a`

                            tagged JmpC '{.c, .a} : if (rf[c]) pc = a;
                                           ^ Sym c : VariablePattern
                                               ^ Sym a : VariablePattern
                                                        ^^ Ref -> `// In m3`\n\\n\---\n\\n\`automatic int rf[] = new [3];`
                                                           ^ Ref -> `.c`
                                                               ^^ Ref -> `// In m3`\n\\n\---\n\\n\`static longint pc = 'x;`
                                                                    ^ Ref -> `.a`

                           endcase

        endcase



        if (instr matches (tagged Jmp .j) &&&
            ^^^^^ Ref -> `// In m3`\n\\n\---\n\\n\`Instr instr;`
                                       ^ Sym j : VariablePattern

            j matches (tagged JmpC '{cc:.c,addr:.a})) begin
            ^ Ref -> `// In m3`\n\\n\---\n\\n\`.j`
                                         ^ Sym c : VariablePattern
                                                 ^ Sym a : VariablePattern

            pc = c[0] & a[0];
            ^^ Ref -> `// In m3`\n\\n\---\n\\n\`static longint pc = 'x;`
                 ^ Ref -> `// In m3`\n\\n\---\n\\n\`.c`
                        ^ Ref -> `// In m3`\n\\n\---\n\\n\`.a`

            pc = instr matches (tagged Jmp .j) &&&
            ^^ Ref -> `// In m3`\n\\n\---\n\\n\`static longint pc = 'x;`
                 ^^^^^ Ref -> `// In m3`\n\\n\---\n\\n\`Instr instr;`

                  j matches (tagged JmpC '{cc:.c,addr:.a}) ? c[0] & a[0] : 0;
                  ^ Ref -> `// In m3`\n\\n\---\n\\n\`.j`
                                                             ^ Ref -> `// In m3`\n\\n\---\n\\n\`.c`
                                                                    ^ Ref -> `// In m3`\n\\n\---\n\\n\`.a`

        end

        else begin

        end

    end



    always_latch begin

    end



    genvar j;
           ^ Sym j : IdentifierName

    for (genvar i = 0; i < 10; i += 2)
                       ^ Ref -> `i`
                               ^ Ref -> `i`

        if (i == 7) begin
            ^ Ref -> `i`

        end



    ;



    generate

        case ($bits(w))
                    ^ Ref -> `wor [1:0] w = 1;`

            0, 1: begin end

            2: begin end

            default: begin end

        endcase

    endgenerate



    assertion0: assert #0 (1 == 1) else $display("Hello!");
    ^^^^^^^^^^ Sym assertion0 : ImmediateAssertStatement

    assertion1: assume final (2 != 1) else $display("Hello!");
    ^^^^^^^^^^ Sym assertion1 : ImmediateAssumeStatement



    if (1) begin

        logic a,b,c,d,e,f;
              ^ Sym a : Declarator
                ^ Sym b : Declarator
                  ^ Sym c : Declarator
                    ^ Sym d : Declarator
                      ^ Sym e : Declarator
                        ^ Sym f : Declarator



        property p1(x,y);
                 ^^ Sym p1 : PropertyDeclaration
                    ^ Sym x : AssertionItemPort
                      ^ Sym y : AssertionItemPort

            ##1 x |-> y;
                ^ Ref -> `x`
                      ^ Ref -> `y`

        endproperty



        wire clk;
             ^^^ Sym clk : Declarator

        property p2;
                 ^^ Sym p2 : PropertyDeclaration

            @(posedge clk)
                      ^^^ Ref -> `// In m3.genblk3`\n\\n\---\n\\n\`wire clk;`

            a ##1 (b || c)[->1] |->
            ^ Ref -> `// In m3.genblk3`\n\\n\---\n\\n\`logic a,b,c,d,e,f;`
                   ^ Ref -> `// In m3.genblk3`\n\\n\---\n\\n\`logic a,b,c,d,e,f;`
                        ^ Ref -> `// In m3.genblk3`\n\\n\---\n\\n\`logic a,b,c,d,e,f;`

                if (b)
                    ^ Ref -> `// In m3.genblk3`\n\\n\---\n\\n\`logic a,b,c,d,e,f;`

                    p1(d,e)
                    ^^ Ref -> `// In m3.genblk3`\n\\n\---\n\\n\`property p1(x,y);\n\    ##1 x |-> y;\n\endproperty`
                       ^ Ref -> `// In m3.genblk3`\n\\n\---\n\\n\`logic a,b,c,d,e,f;`
                         ^ Ref -> `// In m3.genblk3`\n\\n\---\n\\n\`logic a,b,c,d,e,f;`

                else

                    f;
                    ^ Ref -> `// In m3.genblk3`\n\\n\---\n\\n\`logic a,b,c,d,e,f;`

        endproperty

        cover property (p2 and p2);
                        ^^ Ref -> `property p2;\n\    @(posedge clk)\n\    a ##1 (b || c)[->1] |->\n\        if (b)\n\            p1(d,e)\n\        else\n\            f;\n\endproperty`
                               ^^ Ref -> `property p2;\n\    @(posedge clk)\n\    a ##1 (b || c)[->1] |->\n\        if (b)\n\            p1(d,e)\n\        else\n\            f;\n\endproperty`

    end



    prim prim_inst(q, r);
    ^^^^ Ref -> `primitive prim(output reg a, input b);\n\    table\n\        0 : ? : 1;\n\        1 : 0 : x;\n\    endtable\n\endprimitive`
         ^^^^^^^^^ Sym prim_inst : HierarchicalInstance
                   ^ Sym q : IdentifierName
                      ^ Sym r : IdentifierName

    rcmos #1step (q, r, s, t);
                  ^ Ref -> `q`
                     ^ Ref -> `r`
                        ^ Sym s : IdentifierName
                           ^ Sym t : IdentifierName



    defparam m3.m.i = 1:1:1;
                ^ Ref -> `m2 #(\n\    .x_t(y_t)\n\) m (, b, c, d, );`
                  ^ Ref -> `// In m2`\n\\n\---\n\\n\`parameter i = 1`



    clocking cb @(r or s);
             ^^ Sym cb : ClockingDeclaration
                  ^ Ref -> `// In m3`\n\\n\---\n\\n\`r`
                       ^ Ref -> `// In m3`\n\\n\---\n\\n\`s`

        default input posedge #3ps;

        input a = t;
              ^ Sym a : AttributeSpec
                  ^ Ref -> `// In m3`\n\\n\---\n\\n\`t`

    endclocking



    global clocking cb2 @t; endclocking
                    ^^^ Sym cb2 : ClockingDeclaration
                         ^ Ref -> `// In m3`\n\\n\---\n\\n\`t`



    default clocking cb;

    default disable iff 1 dist { [1:2] :/ 3, 2 };



endmodule : m3
            ^^ Ref -> `macromodule m3;`



extern program p(a, b);
               ^ Ref -> `program p(a, b);`



program p(a, b);
        ^ Sym p : ProgramDeclaration
          ^ Sym a : PortReference
             ^ Sym b : PortReference

    input a, b;
          ^ Sym a : Declarator
             ^ Sym b : Declarator

endprogram : p
             ^ Ref -> `program p(a, b);`



extern primitive prim(output reg a, input b);
                 ^^^^ Ref -> `primitive prim(output reg a, input b);\n\    table\n\        0 : ? : 1;\n\        1 : 0 : x;\n\    endtable\n\endprimitive`



primitive prim(output reg a, input b);
          ^^^^ Sym prim : UdpDeclaration
                          ^ Sym a : UdpOutputPortDecl
                                   ^ Sym b : IdentifierName

    table

        0 : ? : 1;

        1 : 0 : x;

    endtable

endprimitive



(* attr = 3.14 *) bind m3.m m1 #(1) bound('x, , , );
                          ^ Ref -> `m2 #(\n\    .x_t(y_t)\n\) m (, b, c, d, );`
                            ^^ Ref -> `module automatic m1 import p::*; #(int i = 1)\n\(a, b, , .c({a, b[0]}));`
                                    ^^^^^ Sym bound : HierarchicalInstance



config cfg;
       ^^^ Sym cfg : ConfigDeclaration

    localparam i = 1;
               ^ Sym i : Declarator

    design work.m3;
                ^^ Ref -> `macromodule m3;`

    default liblist a b;

    cell m3 use work.m3;
         ^^ Ref -> `macromodule m3;`
                     ^^ Ref -> `macromodule m3;`

endconfig



module ALU (o1, i1, i2, opcode);
       ^^^ Sym ALU : ModuleDeclaration
            ^^ Sym o1 : PortReference
                ^^ Sym i1 : PortReference
                    ^^ Sym i2 : PortReference
                        ^^^^^^ Sym opcode : PortReference

    input [7:0] i1, i2;
                ^^ Sym i1 : Declarator
                    ^^ Sym i2 : Declarator

    input [2:1] opcode;
                ^^^^^^ Sym opcode : Declarator

    output [7:0] o1;
                 ^^ Sym o1 : Declarator



    specify

        specparam s1 = 2;
                  ^^ Sym s1 : SpecparamDeclarator

        if (opcode == 2'b00) (i1,i2 *> o1) = (25.0, 25.0);
            ^^^^^^ Ref -> `// In ALU`\n\\n\---\n\\n\`input [2:1] opcode;`
                              ^^ Ref -> `// In ALU`\n\\n\---\n\\n\`input [7:0] i1, i2;`
                                 ^^ Ref -> `// In ALU`\n\\n\---\n\\n\`input [7:0] i1, i2;`
                                       ^^ Ref -> `// In ALU`\n\\n\---\n\\n\`output [7:0] o1;`

        if (opcode == 2'b01) (i1 => o1) = (5.6, 8.0);
            ^^^^^^ Ref -> `// In ALU`\n\\n\---\n\\n\`input [2:1] opcode;`
                              ^^ Ref -> `// In ALU`\n\\n\---\n\\n\`input [7:0] i1, i2;`
                                    ^^ Ref -> `// In ALU`\n\\n\---\n\\n\`output [7:0] o1;`

        if (opcode == s1) (i2 => o1) = (5.6, 8.0);
            ^^^^^^ Ref -> `// In ALU`\n\\n\---\n\\n\`input [2:1] opcode;`
                      ^^ Ref -> `s1 = 2`
                           ^^ Ref -> `// In ALU`\n\\n\---\n\\n\`input [7:0] i1, i2;`
                                 ^^ Ref -> `// In ALU`\n\\n\---\n\\n\`output [7:0] o1;`

        (opcode *> o1) = (6.1, 6.5);
         ^^^^^^ Ref -> `// In ALU`\n\\n\---\n\\n\`input [2:1] opcode;`
                   ^^ Ref -> `// In ALU`\n\\n\---\n\\n\`output [7:0] o1;`

    endspecify

endmodule



interface Iface;
          ^^^^^ Sym Iface : InterfaceDeclaration

    extern function void foo(int i, real r);
                         ^^^ Sym foo : ExternInterfaceMethod
                                 ^ Sym i : Declarator
                                         ^ Sym r : Declarator

    extern forkjoin task t3();
                         ^^ Sym t3 : ExternInterfaceMethod



    modport m(export foo, function void bar(int, logic), task baz, export func);
            ^ Sym m : ModportDeclaration
                     ^^^ Sym foo : ModportNamedPort
                                        ^^^ Sym bar : ModportSubroutinePort
                                                              ^^^ Sym baz : ModportSubroutinePort
                                                                          ^^^^ Sym func : ModportNamedPort

    modport n(import function void func(int), import task t2);
            ^ Sym n : ModportDeclaration
                                   ^^^^ Sym func : ModportSubroutinePort
                                                          ^^ Sym t2 : ModportSubroutinePort

    modport o(export t2);
            ^ Sym o : ModportDeclaration
                     ^^ Sym t2 : ModportNamedPort

endinterface



module n(Iface.m a);
       ^ Sym n : ModuleDeclaration
         ^^^^^ Ref -> `interface Iface;`
               ^ Ref -> `// In Iface`\n\\n\---\n\\n\`modport m(export foo, function void bar(int, logic), task baz, export func);`
                 ^ Sym a : Declarator

    initial begin

        a.foo(42, 3.14);
        ^ Ref -> `Iface.m a`

        a.bar(1, 1);
        ^ Ref -> `Iface.m a`

        a.baz();
        ^ Ref -> `Iface.m a`

    end



    function void a.bar(int i, logic l); endfunction
                  ^ Ref -> `Iface.m a`

    task a.baz; endtask
         ^ Ref -> `Iface.m a`

    function void a.func(int i); endfunction
                  ^ Ref -> `Iface.m a`



    function void a.foo(int i, real r);
                  ^ Ref -> `Iface.m a`

    endfunction

endmodule



module m4;
       ^^ Sym m4 : ModuleDeclaration

    Iface i1();
    ^^^^^ Ref -> `interface Iface;`
          ^^ Sym i1 : HierarchicalInstance

    n n1(i1);
    ^ Ref -> `module n(Iface.m a);`
      ^^ Sym n1 : HierarchicalInstance
         ^^ Ref -> `Iface i1();`



    Iface i2();
    ^^^^^ Ref -> `interface Iface;`
          ^^ Sym i2 : HierarchicalInstance

    n n2(i2.m);
    ^ Ref -> `module n(Iface.m a);`
      ^^ Sym n2 : HierarchicalInstance
         ^^ Ref -> `Iface i2();`
            ^ Ref -> `// In Iface`\n\\n\---\n\\n\`modport m(export foo, function void bar(int, logic), task baz, export func);`



    localparam int baz = 3;
                   ^^^ Sym baz : Declarator

    task i1.t2;
         ^^ Ref -> `Iface i1();`

        static int i = baz;
                       ^^^ Ref -> `localparam int baz = 3`

    endtask



    task i2.t2;
         ^^ Ref -> `Iface i2();`

        static int i = baz;
                       ^^^ Ref -> `localparam int baz = 3`

    endtask

endmodule



typedef enum { cover_none, cover_all } coverage_level;
                                       ^^^^^^^^^^^^^^ Sym coverage_level : TypedefDeclaration

checker assert_window1 (
        ^^^^^^^^^^^^^^ Sym assert_window1 : CheckerDeclaration

    logic test_expr,
          ^^^^^^^^^ Sym test_expr : AssertionItemPort

    untyped start_event,
            ^^^^^^^^^^^ Sym start_event : AssertionItemPort

    untyped end_event,
            ^^^^^^^^^ Sym end_event : AssertionItemPort

    event clock = $inferred_clock,
          ^^^^^ Sym clock : AssertionItemPort

    logic reset = $inferred_disable,
          ^^^^^ Sym reset : AssertionItemPort

    string error_msg = "violation",
           ^^^^^^^^^ Sym error_msg : AssertionItemPort

    coverage_level clevel = cover_all
    ^^^^^^^^^^^^^^ Ref -> `typedef enum { cover_none, cover_all } coverage_level;`
                   ^^^^^^ Sym clevel : AssertionItemPort
                            ^^^^^^^^^ Ref -> `// In coverage_level`\n\\n\---\n\\n\`typedef enum { cover_none, cover_all } coverage_level;`

);

    default clocking @clock; endclocking
                      ^^^^^ Ref -> `// In assert_window1`\n\\n\---\n\\n\`event clock = $inferred_clock`

    default disable iff reset;
                        ^^^^^ Ref -> `logic reset = $inferred_disable`

    bit window = 1'b0, next_window = 1'b1;
        ^^^^^^ Sym window : Declarator
                       ^^^^^^^^^^^ Sym next_window : Declarator

    rand bit q;
             ^ Sym q : Declarator



    always_comb begin

        if (reset || window && end_event)
            ^^^^^ Ref -> `logic reset = $inferred_disable`
                     ^^^^^^ Ref -> `bit window = 1'b0, next_window = 1'b1;`
                               ^^^^^^^^^ Ref -> `untyped end_event`

            next_window = 1'b0;
            ^^^^^^^^^^^ Ref -> `bit window = 1'b0, next_window = 1'b1;`

        else if (!window && start_event)
                  ^^^^^^ Ref -> `bit window = 1'b0, next_window = 1'b1;`
                            ^^^^^^^^^^^ Ref -> `untyped start_event`

            next_window = 1'b1;
            ^^^^^^^^^^^ Ref -> `bit window = 1'b0, next_window = 1'b1;`

        else

            next_window = window;
            ^^^^^^^^^^^ Ref -> `bit window = 1'b0, next_window = 1'b1;`
                          ^^^^^^ Ref -> `bit window = 1'b0, next_window = 1'b1;`

    end



    always_ff @clock
               ^^^^^ Ref -> `event clock = $inferred_clock`

        window <= next_window;
        ^^^^^^ Ref -> `bit window = 1'b0, next_window = 1'b1;`
                  ^^^^^^^^^^^ Ref -> `bit window = 1'b0, next_window = 1'b1;`



    property p_window;
             ^^^^^^^^ Sym p_window : PropertyDeclaration

        start_event && !window |=> test_expr[+] ##0 end_event;
        ^^^^^^^^^^^ Ref -> `// In assert_window1`\n\\n\---\n\\n\`untyped start_event`
                        ^^^^^^ Ref -> `// In assert_window1`\n\\n\---\n\\n\`bit window = 1'b0, next_window = 1'b1;`
                                   ^^^^^^^^^ Ref -> `// In assert_window1`\n\\n\---\n\\n\`logic test_expr`
                                                    ^^^^^^^^^ Ref -> `// In assert_window1`\n\\n\---\n\\n\`untyped end_event`

    endproperty



    a_window: assert property (p_window) else $error(error_msg);
    ^^^^^^^^ Sym a_window : AssertPropertyStatement
                               ^^^^^^^^ Ref -> `// In assert_window1`\n\\n\---\n\\n\`property p_window;\n\    start_event && !window |=> test_expr[+] ##0 end_event;\n\endproperty`
                                                     ^^^^^^^^^ Ref -> `// In assert_window1`\n\\n\---\n\\n\`string error_msg = "violation"`



    generate if (clevel != cover_none) begin : cover_b
                 ^^^^^^ Ref -> `coverage_level clevel = cover_all`
                           ^^^^^^^^^^ Ref -> `// In coverage_level`\n\\n\---\n\\n\`typedef enum { cover_none, cover_all } coverage_level;`
                                               ^^^^^^^ Sym cover_b : GenerateBlock

        cover_window_open: cover property (start_event && !window)
        ^^^^^^^^^^^^^^^^^ Sym cover_window_open : CoverPropertyStatement
                                           ^^^^^^^^^^^ Ref -> `// In assert_window1`\n\\n\---\n\\n\`untyped start_event`
                                                           ^^^^^^ Ref -> `// In assert_window1`\n\\n\---\n\\n\`bit window = 1'b0, next_window = 1'b1;`

        $display("window_open covered");

        cover_window: cover property (
        ^^^^^^^^^^^^ Sym cover_window : CoverPropertyStatement

            start_event && !window
            ^^^^^^^^^^^ Ref -> `// In assert_window1`\n\\n\---\n\\n\`untyped start_event`
                            ^^^^^^ Ref -> `// In assert_window1`\n\\n\---\n\\n\`bit window = 1'b0, next_window = 1'b1;`

            ##1 (!end_event && window) [*]
                  ^^^^^^^^^ Ref -> `// In assert_window1`\n\\n\---\n\\n\`untyped end_event`
                               ^^^^^^ Ref -> `// In assert_window1`\n\\n\---\n\\n\`bit window = 1'b0, next_window = 1'b1;`

            ##1 end_event && window
                ^^^^^^^^^ Ref -> `// In assert_window1`\n\\n\---\n\\n\`untyped end_event`
                             ^^^^^^ Ref -> `// In assert_window1`\n\\n\---\n\\n\`bit window = 1'b0, next_window = 1'b1;`

        ) $display("window covered");

    end : cover_b

    endgenerate

endchecker : assert_window1



module m5;
       ^^ Sym m5 : ModuleDeclaration

    logic a, b, c, d, e, clk;
          ^ Sym a : Declarator
             ^ Sym b : Declarator
                ^ Sym c : Declarator
                   ^ Sym d : Declarator
                      ^ Sym e : Declarator
                         ^^^ Sym clk : Declarator



    default clocking @(posedge clk); endclocking
                               ^^^ Ref -> `// In m5`\n\\n\---\n\\n\`logic a, b, c, d, e, clk;`



    assert_window1 aw1(1 + 1, a, b);
                   ^^^ Sym aw1 : HierarchicalInstance
                              ^ Ref -> `logic a, b, c, d, e, clk;`
                                 ^ Ref -> `logic a, b, c, d, e, clk;`



    initial begin

        assert_window1 aw2(1 + 1, a, b);
        ^^^^^^^^^^^^^^ Ref -> `checker assert_window1 (\n\    logic test_expr,\n\    untyped start_event,\n\    untyped end_event,\n\    event clock = $inferred_clock,\n\    logic reset = $inferred_disable,\n\    string error_msg = "violation",\n\    coverage_level clevel = cover_all\n\);\n\    default clocking @clock; endclocking\n\    default disable iff reset;\n\    bit window = 1'b0, next_window = 1'b1;\n\    rand bit q;\n\    always_comb begin\n\        if (reset || window && end_event)\n\            next_window = 1'b0;\n\        else if (!window && start_event)\n\            next_window = 1'b1;\n\        else\n\            next_window = window;\n\    end\n\    always_ff @clock\n\        window <= next_window;\n\    property p_window;\n\        start_event && !window |=> test_expr[+] ##0 end_event;\n\    endproperty\n\    a_window: assert property (p_window) else $error(error_msg);\n\    generate if (clevel != cover_none) begin : cover_b\n\        cover_window_open: cover property (start_event && !window)\n\        $display("window_open covered");\n\        cover_window: cover property (\n\            start_event && !window\n\            ##1 (!end_event && window) [*]\n\            ##1 end_event && window\n\        ) $display("window covered");\n\    end : cover_b\n\    endgenerate\n\endchecker : assert_window1`
                       ^^^ Sym aw2 : HierarchicalInstance
                                  ^ Ref -> `// In m5`\n\\n\---\n\\n\`logic a, b, c, d, e, clk;`
                                     ^ Ref -> `// In m5`\n\\n\---\n\\n\`logic a, b, c, d, e, clk;`

    end



    sequence abc;
             ^^^ Sym abc : SequenceDeclaration

        @(posedge clk) a ##1 b ##1 c;
                  ^^^ Ref -> `// In m5`\n\\n\---\n\\n\`logic a, b, c, d, e, clk;`
                       ^ Ref -> `// In m5`\n\\n\---\n\\n\`logic a, b, c, d, e, clk;`
                             ^ Ref -> `// In m5`\n\\n\---\n\\n\`logic a, b, c, d, e, clk;`
                                   ^ Ref -> `// In m5`\n\\n\---\n\\n\`logic a, b, c, d, e, clk;`

    endsequence



    sequence de;
             ^^ Sym de : SequenceDeclaration

        @(negedge clk) d ##[2:5] e;
                  ^^^ Ref -> `// In m5`\n\\n\---\n\\n\`logic a, b, c, d, e, clk;`
                       ^ Ref -> `// In m5`\n\\n\---\n\\n\`logic a, b, c, d, e, clk;`
                                 ^ Ref -> `// In m5`\n\\n\---\n\\n\`logic a, b, c, d, e, clk;`

    endsequence



    program check;
            ^^^^^ Sym check : ProgramDeclaration

        initial begin

            wait( abc.triggered || de.triggered );
                  ^^^ Ref -> `// In m5`\n\\n\---\n\\n\`sequence abc;\n\    @(posedge clk) a ##1 b ##1 c;\n\endsequence`
                                   ^^ Ref -> `// In m5`\n\\n\---\n\\n\`sequence de;\n\    @(negedge clk) d ##[2:5] e;\n\endsequence`

            if( abc.triggered )
                ^^^ Ref -> `// In m5`\n\\n\---\n\\n\`sequence abc;\n\    @(posedge clk) a ##1 b ##1 c;\n\endsequence`

                $display( "abc succeeded" );

            if( de.triggered )
                ^^ Ref -> `// In m5`\n\\n\---\n\\n\`sequence de;\n\    @(negedge clk) d ##[2:5] e;\n\endsequence`

                $display( "de succeeded" );

        end

    endprogram

endmodule



class C;
      ^ Sym C : ClassDeclaration

    int i;
        ^ Sym i : Declarator

    static int j;
               ^ Sym j : Declarator

    extern function int foo(int bar, int baz = 1);
                        ^^^ Sym foo : ClassMethodPrototype
                                ^^^ Sym bar : Declarator
                                         ^^^ Sym baz : Declarator

endclass



class D;
      ^ Sym D : ClassDeclaration

    extern static function real foo;
                                ^^^ Sym foo : ClassMethodPrototype

endclass



localparam int k = 5;
               ^ Sym k : Declarator



function int C::foo(int bar, int baz = 1);

    i = j + k + bar + baz;

endfunction



function real D::foo;

endfunction



class G #(type T);
      ^ Sym G : ClassDeclaration

    extern function T foo;

endclass



function G::T G::foo;

    return 0;

endfunction



class H #(int p);
      ^ Sym H : ClassDeclaration
              ^ Ref -> `program p(a, b);`

    extern function int foo;

endclass



function int H::foo;

endfunction



module m7;
       ^^ Sym m7 : ModuleDeclaration

    G #(real) g1;
    ^ Ref -> `class G #(type T);\n\    extern function T foo;\n\endclass`
              ^^ Sym g1 : Declarator

    G #(int) g2;
    ^ Ref -> `class G #(type T);\n\    extern function T foo;\n\endclass`
             ^^ Sym g2 : Declarator



    int i = g2.foo();
        ^ Sym i : Declarator
            ^^ Ref -> `G #(int) g2;`
               ^^^ Ref -> `// In G`\n\\n\---\n\\n\`function G::T G::foo;\n\    return 0;\n\endfunction`

    real r = D::foo();
         ^ Sym r : Declarator
             ^ Ref -> `class D;\n\    extern static function real foo;\n\endclass`
                ^^^ Ref -> `// In D`\n\\n\---\n\\n\`function real D::foo;\n\endfunction`

endmodule



class A;
      ^ Sym A : ClassDeclaration

    integer i = 1;
            ^ Sym i : Declarator

    integer j = 2;
            ^ Sym j : Declarator

    function integer f();
                     ^ Sym f : FunctionDeclaration

        f = i;
            ^ Ref -> `// In A`\n\\n\---\n\\n\`integer i = 1;`

    endfunction

endclass



class B extends A;
      ^ Sym B : ClassDeclaration
                ^ Ref -> `class A;\n\    integer i = 1;\n\    integer j = 2;\n\    function integer f();\n\        f = i;\n\    endfunction\n\endclass`

    integer i = 2;
            ^ Sym i : Declarator

    function void f();
                  ^ Sym f : FunctionDeclaration

        i = j;
        ^ Ref -> `// In B`\n\\n\---\n\\n\`integer i = 2;`
            ^ Ref -> `// In A`\n\\n\---\n\\n\`integer j = 2;`

        super.i = super.j;
              ^ Ref -> `// In A`\n\\n\---\n\\n\`integer i = 1;`
                        ^ Ref -> `// In A`\n\\n\---\n\\n\`integer j = 2;`

        j = super.f();
        ^ Ref -> `// In A`\n\\n\---\n\\n\`integer j = 2;`
                  ^ Ref -> `// In A`\n\\n\---\n\\n\`function integer f();\n\    f = i;\n\endfunction`

        j = this.super.f();
        ^ Ref -> `// In A`\n\\n\---\n\\n\`integer j = 2;`
                       ^ Ref -> `// In A`\n\\n\---\n\\n\`function integer f();\n\    f = i;\n\endfunction`

    endfunction

endclass



class C2 extends B;
      ^^ Sym C2 : ClassDeclaration
                 ^ Ref -> `class B extends A;\n\    integer i = 2;\n\    function void f();\n\        i = j;\n\        super.i = super.j;\n\        j = super.f();\n\        j = this.super.f();\n\    endfunction\n\endclass`

    function void g();
                  ^ Sym g : FunctionDeclaration

        f();
        ^ Ref -> `// In B`\n\\n\---\n\\n\`function void f();\n\    i = j;\n\    super.i = super.j;\n\    j = super.f();\n\    j = this.super.f();\n\endfunction`

        i = j + C::j + A::f();
        ^ Ref -> `// In B`\n\\n\---\n\\n\`integer i = 2;`
            ^ Ref -> `// In A`\n\\n\---\n\\n\`integer j = 2;`
                ^ Ref -> `class C;\n\    int i;\n\    static int j;\n\    extern function int foo(int bar, int baz = 1);\n\endclass`
                   ^ Ref -> `// In C`\n\\n\---\n\\n\`int j;`
                       ^ Ref -> `class A;\n\    integer i = 1;\n\    integer j = 2;\n\    function integer f();\n\        f = i;\n\    endfunction\n\endclass`
                          ^ Ref -> `// In A`\n\\n\---\n\\n\`function integer f();\n\    f = i;\n\endfunction`

    endfunction



    rand bit [63:0] value;
                    ^^^^^ Sym value : Declarator

    rand logic q;
               ^ Sym q : Declarator

    constraint value_c {
               ^^^^^^^ Sym value_c : ConstraintDeclaration

        value[63] dist {0 :/ 70, 1 :/ 30};
        ^^^^^ Ref -> `// In C2`\n\\n\---\n\\n\`bit [63:0] value;`

        value[0] == 1'b0;
        ^^^^^ Ref -> `// In C2`\n\\n\---\n\\n\`bit [63:0] value;`

        value[15:8] inside {
        ^^^^^ Ref -> `// In C2`\n\\n\---\n\\n\`bit [63:0] value;`

            8'h0,

            8'hF

        };

        solve value before q;
              ^^^^^ Ref -> `// In C2`\n\\n\---\n\\n\`bit [63:0] value;`
                           ^ Ref -> `// In C2`\n\\n\---\n\\n\`logic q;`

        soft value[3:1] > 1;
             ^^^^^ Ref -> `// In C2`\n\\n\---\n\\n\`bit [63:0] value;`

        q -> { value[4] == 0; }
        ^ Ref -> `// In C2`\n\\n\---\n\\n\`logic q;`
               ^^^^^ Ref -> `// In C2`\n\\n\---\n\\n\`bit [63:0] value;`

        if (q) { foreach (value[b]) { value[b] == 0; } } else { disable soft value; }
            ^ Ref -> `// In C2`\n\\n\---\n\\n\`logic q;`
                          ^^^^^ Ref -> `// In C2`\n\\n\---\n\\n\`bit [63:0] value;`
                                      ^^^^^ Ref -> `// In C2`\n\\n\---\n\\n\`bit [63:0] value;`
                                                                             ^^^^^ Ref -> `// In C2`\n\\n\---\n\\n\`bit [63:0] value;`

    }

endclass



module m6;
       ^^ Sym m6 : ModuleDeclaration

    A a = new;
    ^ Ref -> `class A;\n\    integer i = 1;\n\    integer j = 2;\n\    function integer f();\n\        f = i;\n\    endfunction\n\endclass`
      ^ Sym a : Declarator

    A b1 = B::new;
    ^ Ref -> `class A;\n\    integer i = 1;\n\    integer j = 2;\n\    function integer f();\n\        f = i;\n\    endfunction\n\endclass`
      ^^ Sym b1 : Declarator
           ^ Ref -> `class B extends A;\n\    integer i = 2;\n\    function void f();\n\        i = j;\n\        super.i = super.j;\n\        j = super.f();\n\        j = this.super.f();\n\    endfunction\n\endclass`

    B b2 = new;
    ^ Ref -> `class B extends A;\n\    integer i = 2;\n\    function void f();\n\        i = j;\n\        super.i = super.j;\n\        j = super.f();\n\        j = this.super.f();\n\    endfunction\n\endclass`
      ^^ Sym b2 : Declarator

    C2 c = new;
    ^^ Ref -> `class C2 extends B;\n\    function void g();\n\        f();\n\        i = j + C::j + A::f();\n\    endfunction\n\    rand bit [63:0] value;\n\    rand logic q;\n\    constraint value_c {\n\        value[63] dist {0 :/ 70, 1 :/ 30};\n\        value[0] == 1'b0;\n\        value[15:8] inside {\n\            8'h0,\n\            8'hF\n\        };\n\        solve value before q;\n\        soft value[3:1] > 1;\n\        q -> { value[4] == 0; }\n\        if (q) { foreach (value[b]) { value[b] == 0; } } else { disable soft value; }\n\    }\n\endclass`
       ^ Sym c : Declarator

    int depth;
        ^^^^^ Sym depth : Declarator

    integer i = b1.f();
            ^ Sym i : Declarator
                ^^ Ref -> `A b1 = B::new;`
                   ^ Ref -> `// In A`\n\\n\---\n\\n\`function integer f();\n\    f = i;\n\endfunction`

    initial begin

        b2.f();
        ^^ Ref -> `B b2 = new;`
           ^ Ref -> `// In B`\n\\n\---\n\\n\`function void f();\n\    i = j;\n\    super.i = super.j;\n\    j = super.f();\n\    j = this.super.f();\n\endfunction`

        a = b2;
        ^ Ref -> `A a = new;`
            ^^ Ref -> `B b2 = new;`

        c.i = c.j;
        ^ Ref -> `C2 c = new;`
          ^ Ref -> `// In B`\n\\n\---\n\\n\`integer i = 2;`
              ^ Ref -> `C2 c = new;`
                ^ Ref -> `// In A`\n\\n\---\n\\n\`integer j = 2;`



        randsequence(main)

            main : first second;
            ^^^^ Sym main : Production

            first : add | dec := (1 + 1);
            ^^^^^ Sym first : Production

            second : repeat($urandom_range(2, 6)) first;
            ^^^^^^ Sym second : Production

            add : if (depth < 2) first else second;
            ^^^ Sym add : Production
                      ^^^^^ Ref -> `// In m6`\n\\n\---\n\\n\`int depth;`

            dec : case (depth & 7)
            ^^^ Sym dec : Production
                        ^^^^^ Ref -> `// In m6`\n\\n\---\n\\n\`int depth;`

                0 : add;

                1, 2 : dec;

                default : first;

            endcase;

            third : rand join first second;
            ^^^^^ Sym third : Production

            fourth(string s = "done") : { if (depth) break; };
            ^^^^^^ Sym fourth : Production
                          ^ Sym s : Declarator
                                              ^^^^^ Ref -> `// In m6`\n\\n\---\n\\n\`int depth;`

        endsequence

    end

endmodule



class C3;
      ^^ Sym C3 : ClassDeclaration

    enum {red, green, blue} color;
                            ^^^^^ Sym color : Declarator

    bit [3:0] pixel_adr, pixel_offset, pixel_hue;
              ^^^^^^^^^ Sym pixel_adr : Declarator
                         ^^^^^^^^^^^^ Sym pixel_offset : Declarator
                                       ^^^^^^^^^ Sym pixel_hue : Declarator

    logic clk, x, y, c;
          ^^^ Sym clk : Declarator
               ^ Sym x : Declarator
                  ^ Sym y : Declarator
                     ^ Sym c : Declarator



    covergroup g2 (string instComment) @(posedge clk);
                          ^^^^^^^^^^^ Sym instComment : Declarator
                                                 ^^^ Ref -> `// In C3`\n\\n\---\n\\n\`logic clk, x, y, c;`

        Offset: coverpoint pixel_offset;
        ^^^^^^ Sym Offset : Coverpoint
                           ^^^^^^^^^^^^ Ref -> `// In C3`\n\\n\---\n\\n\`bit [3:0] pixel_adr, pixel_offset, pixel_hue;`

        Hue: coverpoint pixel_hue;
        ^^^ Sym Hue : Coverpoint
                        ^^^^^^^^^ Ref -> `// In C3`\n\\n\---\n\\n\`bit [3:0] pixel_adr, pixel_offset, pixel_hue;`

        AxC: cross color, pixel_adr;
        ^^^ Sym AxC : CoverCross

        all: cross color, Hue, Offset;
        ^^^ Sym all : CoverCross
                          ^^^ Ref -> `// In C3`\n\\n\---\n\\n\`Hue: coverpoint pixel_hue;`
                               ^^^^^^ Ref -> `// In C3`\n\\n\---\n\\n\`Offset: coverpoint pixel_offset;`



        option.comment = instComment;
                         ^^^^^^^^^^^ Ref -> `string instComment`



        e: coverpoint x iff (clk) {
        ^ Sym e : Coverpoint
                      ^ Ref -> `// In C3`\n\\n\---\n\\n\`logic clk, x, y, c;`
                             ^^^ Ref -> `// In C3`\n\\n\---\n\\n\`logic clk, x, y, c;`

            option.weight = 2;

            wildcard bins a = { [0:63],65 };
                          ^ Sym a : CoverageBins

            bins b[] = { [127:150],[148:191] }; // note overlapping values
                 ^ Sym b : CoverageBins

            bins c[] = { 200,201,202 };
                 ^ Sym c : CoverageBins

            bins d = { [1000:$] };
                 ^ Sym d : CoverageBins

            bins others[] = default;
                 ^^^^^^ Sym others : CoverageBins



            bins sa = (4 => 5 => 6), ([7:9],10 => 11,12);
                 ^^ Sym sa : CoverageBins

            bins sb[] = (12 => 3 [* 1]);
                 ^^ Sym sb : CoverageBins

            bins sc = (12 => 3 [-> 1]);
                 ^^ Sym sc : CoverageBins

            bins sd = (12 => 3 [= 1:2]);
                 ^^ Sym sd : CoverageBins

        }

        cross e, y {
              ^ Ref -> `// In C3`\n\\n\---\n\\n\`e: coverpoint x iff (clk) {\n\    option.weight = 2;\n\    wildcard bins a = { [0:63],65 };\n\    bins b[] = { [127:150],[148:191] }; // note overlapping values\n\    bins c[] = { 200,201,202 };\n\    bins d = { [1000:$] };\n\    bins others[] = default;\n\    bins sa = (4 => 5 => 6), ([7:9],10 => 11,12);\n\    bins sb[] = (12 => 3 [* 1]);\n\    bins sc = (12 => 3 [-> 1]);\n\    bins sd = (12 => 3 [= 1:2]);\n\}`

            option.weight = c;
                            ^ Ref -> `// In C3`\n\\n\---\n\\n\`logic clk, x, y, c;`

            bins one = '{ '{1,2}, '{3,4}, '{5,6} };
                 ^^^ Sym one : BinsSelection

            ignore_bins others = (!binsof(e.a) || !binsof(y) intersect {1}) with (e > 10);
                        ^^^^^^ Sym others : BinsSelection
                                          ^ Ref -> `// In C3`\n\\n\---\n\\n\`e: coverpoint x iff (clk) {\n\    option.weight = 2;\n\    wildcard bins a = { [0:63],65 };\n\    bins b[] = { [127:150],[148:191] }; // note overlapping values\n\    bins c[] = { 200,201,202 };\n\    bins d = { [1000:$] };\n\    bins others[] = default;\n\    bins sa = (4 => 5 => 6), ([7:9],10 => 11,12);\n\    bins sb[] = (12 => 3 [* 1]);\n\    bins sc = (12 => 3 [-> 1]);\n\    bins sd = (12 => 3 [= 1:2]);\n\}`
                                            ^ Ref -> `// In C3.e`\n\\n\---\n\\n\`wildcard bins a = { [0:63],65 };`
                                                                                  ^ Ref -> `// In C3`\n\\n\---\n\\n\`e: coverpoint x iff (clk) {\n\    option.weight = 2;\n\    wildcard bins a = { [0:63],65 };\n\    bins b[] = { [127:150],[148:191] }; // note overlapping values\n\    bins c[] = { 200,201,202 };\n\    bins d = { [1000:$] };\n\    bins others[] = default;\n\    bins sa = (4 => 5 => 6), ([7:9],10 => 11,12);\n\    bins sb[] = (12 => 3 [* 1]);\n\    bins sc = (12 => 3 [-> 1]);\n\    bins sd = (12 => 3 [= 1:2]);\n\}`

        }

        b: cross y, x;
        ^ Sym b : CoverCross

    endgroup

endclass



module m9;
       ^^ Sym m9 : ModuleDeclaration

    logic [3:0] a = {4 {1'b1}};
                ^ Sym a : Declarator

endmodule



module m10;
       ^^^ Sym m10 : ModuleDeclaration

    byte stream[$];
         ^^^^^^ Sym stream : Declarator

    class Packet;
          ^^^^^^ Sym Packet : ClassDeclaration

        rand int header;
                 ^^^^^^ Sym header : Declarator

        rand int len;
                 ^^^ Sym len : Declarator

        rand byte payload[];
                  ^^^^^^^ Sym payload : Declarator

        int crc;
            ^^^ Sym crc : Declarator

        constraint G { len > 1; payload.size == len ; }
                   ^ Sym G : ConstraintDeclaration
                       ^^^ Ref -> `// In m10.Packet`\n\\n\---\n\\n\`int len;`
                                ^^^^^^^ Ref -> `// In m10.Packet`\n\\n\---\n\\n\`byte payload[];`
                                                ^^^ Ref -> `// In m10.Packet`\n\\n\---\n\\n\`int len;`

        function void post_randomize; crc = payload.sum; endfunction
                      ^^^^^^^^^^^^^^ Sym post_randomize : FunctionDeclaration
                                      ^^^ Ref -> `// In m10.Packet`\n\\n\---\n\\n\`int crc;`
                                            ^^^^^^^ Ref -> `// In m10.Packet`\n\\n\---\n\\n\`byte payload[];`

    endclass



    initial begin

        byte q[$];
             ^ Sym q : Declarator

        automatic Packet p = new;
                  ^^^^^^ Ref -> `// In m10`\n\\n\---\n\\n\`class Packet;\n\    rand int header;\n\    rand int len;\n\    rand byte payload[];\n\    int crc;\n\    constraint G { len > 1; payload.size == len ; }\n\    function void post_randomize; crc = payload.sum; endfunction\n\endclass`
                         ^ Sym p : Declarator

        {<< byte{ p.header, p.len, p.payload with [0 +: p.len], p.crc }} = stream;
                  ^ Ref -> `automatic Packet p = new;`
                    ^^^^^^ Ref -> `// In m10.Packet`\n\\n\---\n\\n\`int header;`
                            ^ Ref -> `automatic Packet p = new;`
                              ^^^ Ref -> `// In m10.Packet`\n\\n\---\n\\n\`int len;`
                                   ^ Ref -> `automatic Packet p = new;`
                                     ^^^^^^^ Ref -> `// In m10.Packet`\n\\n\---\n\\n\`byte payload[];`
                                                        ^ Ref -> `automatic Packet p = new;`
                                                          ^^^ Ref -> `// In m10.Packet`\n\\n\---\n\\n\`int len;`
                                                                ^ Ref -> `automatic Packet p = new;`
                                                                  ^^^ Ref -> `// In m10.Packet`\n\\n\---\n\\n\`int crc;`
                                                                           ^^^^^^ Ref -> `// In m10`\n\\n\---\n\\n\`byte stream[$];`

        stream = stream[ $bits(p) / 8 : $ ];
        ^^^^^^ Ref -> `// In m10`\n\\n\---\n\\n\`byte stream[$];`
                 ^^^^^^ Ref -> `// In m10`\n\\n\---\n\\n\`byte stream[$];`
                               ^ Ref -> `automatic Packet p = new;`

    end

endmodule
