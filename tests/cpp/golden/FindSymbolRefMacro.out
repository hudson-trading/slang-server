
// Comprehensive macro test file covering various macro scenarios

// Based on test cases from tests/unittests/parsing/DiagnosticTests.cpp



// Basic macro definitions

`define SIMPLE_MACRO 42

`define FUNC_MACRO(x) (x + 1)

`define TWO_ARG_MACRO(a, b) (a + b)



// Use macros from common_macros.svh

`define BUS_WIDTH `WIDTH
                  ^^^^^^ Ref -> `// From common_macros.svh`\n\\n\---\n\\n\``define WIDTH 32`

`define MEM_SIZE `DEPTH
                 ^^^^^^ Ref -> `// From common_macros.svh`\n\\n\---\n\\n\``define DEPTH 1024`

`define ADDR_BITS `ADDR_WIDTH
                  ^^^^^^^^^^^ Ref -> `// From common_macros.svh`\n\\n\---\n\\n\``define ADDR_WIDTH $clog2(`DEPTH)`



// Nested macro definitions

`define FOO(blah) blah

`define BAR(blah) `FOO(blah)
                  ^^^^ Ref -> `// Nested macro definitions\n\`define FOO(blah) blah`

`define BAZ(xy) xy



// More complex nested macros

`define COMPLEX_FOO(blah, flurb) blah+`BAZ(flurb)
                                      ^^^^ Ref -> ``define BAZ(xy) xy`

`define COMPLEX_BAR(blah, flurb) `COMPLEX_FOO(blah, flurb)
                                 ^^^^^^^^^^^^ Ref -> `// More complex nested macros\n\`define COMPLEX_FOO(blah, flurb) blah+`BAZ(flurb)`



// Macros that create syntax issues

`define INCOMPLETE_PAREN (i

`define CLOSING_PAREN 1)

`define COMBINED_MACRO `INCOMPLETE_PAREN + `CLOSING_PAREN ()
                       ^^^^^^^^^^^^^^^^^ Ref -> `// Macros that create syntax issues\n\`define INCOMPLETE_PAREN (i`
                                           ^^^^^^^^^^^^^^ Ref -> ``define CLOSING_PAREN 1)`



// Macro with concatenation and pass-through

`define PASS(asdf, barr) asdf barr

`define PASS_SINGLE(asdf) asdf



`define DECLARE_INT(name, val) localparam int name = val;



`define INFO(msg) $display("Info: %s", msg);



// Line directive testing

// TODO: fix the test handling of this, although this is typically for generated code

// `line 100 "macro_test.svh" 0



module test;
       ^^^^ Sym test : Definition



    // Basic struct for testing member access

    typedef struct {

        int i;
            ^ Sym i : Field

        logic [7:0] data;
                    ^^^^ Sym data : Field

    } test_struct;
      ^^^^^^^^^^^ Sym test_struct : TypeAlias



    // Enum for testing macro with enum values

    typedef enum {

        STATE_IDLE = 0,
        ^^^^^^^^^^ Sym STATE_IDLE : EnumValue

        STATE_ACTIVE = 1,
        ^^^^^^^^^^^^ Sym STATE_ACTIVE : EnumValue

        STATE_WAIT = 2,
        ^^^^^^^^^^ Sym STATE_WAIT : EnumValue

        STATE_DONE = 3
        ^^^^^^^^^^ Sym STATE_DONE : EnumValue

    } state_t;
      ^^^^^^^ Sym state_t : TypeAlias



    // Variables for testing - use macros from common_macros.svh

    int test_var;
        ^^^^^^^^ Sym test_var : Variable

    logic [`BUS_WIDTH-1:0] bus_signal;
           ^^^^^^^^^^ Ref -> `// Use macros from common_macros.svh\n\`define BUS_WIDTH `WIDTH`
                           ^^^^^^^^^^ Sym bus_signal : Variable

    logic [`ADDR_BITS-1:0] address;
           ^^^^^^^^^^ Ref -> ``define ADDR_BITS `ADDR_WIDTH`
                           ^^^^^^^ Sym address : Variable



    // Use CREATE_REG macro from common_macros.svh

    `CREATE_REG(status_reg, 8)
    ^^^^^^^^^^^ Ref -> `// From common_macros.svh`\n\\n\---\n\\n\``define CREATE_REG(name, width) \\n\logic [width-1:0] name; \\n\assign name = {width{1'b0}};`

    `CREATE_REG(control_reg, 16)
    ^^^^^^^^^^^ Ref -> `// From common_macros.svh`\n\\n\---\n\\n\``define CREATE_REG(name, width) \\n\logic [width-1:0] name; \\n\assign name = {width{1'b0}};`



    // Test simple macro usage

    localparam int SIMPLE_VAL = `SIMPLE_MACRO;
                   ^^^^^^^^^^ Sym SIMPLE_VAL : Parameter
                                ^^^^^^^^^^^^^ Ref -> `// Basic macro definitions\n\`define SIMPLE_MACRO 42`



    // Test function macro

    localparam int FUNC_VAL = `FUNC_MACRO(10);
                   ^^^^^^^^ Sym FUNC_VAL : Parameter
                              ^^^^^^^^^^^ Ref -> ``define FUNC_MACRO(x) (x + 1)`



    // Test two argument macro

    localparam int TWO_ARG_VAL = `TWO_ARG_MACRO(5, 7);
                   ^^^^^^^^^^^ Sym TWO_ARG_VAL : Parameter
                                 ^^^^^^^^^^^^^^ Ref -> ``define TWO_ARG_MACRO(a, b) (a + b)`



    // Test definition behind macro

    `DECLARE_INT(some_int, 1)
    ^^^^^^^^^^^^ Ref -> ``define DECLARE_INT(name, val) localparam int name = val;`
                 ^^^^^^^^ Ref -> `localparam int some_int = 1`\n\ Expanded from\n\ ``DECLARE_INT(some_int, 1)`

    `DECLARE_INT(other_int, 2)
    ^^^^^^^^^^^^ Ref -> ``define DECLARE_INT(name, val) localparam int name = val;`
                 ^^^^^^^^^ Ref -> `localparam int other_int = 2`\n\ Expanded from\n\ ``DECLARE_INT(other_int, 2)`



    // test function calls in macro arguments

    `DECLARE_INT(log_int, $clog2(other_int))
    ^^^^^^^^^^^^ Ref -> ``define DECLARE_INT(name, val) localparam int name = val;`
                 ^^^^^^^ Ref -> `localparam int log_int = $clog2(other_int)`\n\ Expanded from\n\ ``DECLARE_INT(log_int, $clog2(other_int))`
                                 ^^^^^^^^^ Ref -> `localparam int other_int = 2`\n\ Expanded from\n\ ``DECLARE_INT(other_int, 2)`



    // Test macro with enum value arguments

    `DECLARE_INT(initial_state, STATE_IDLE)
    ^^^^^^^^^^^^ Ref -> ``define DECLARE_INT(name, val) localparam int name = val;`
                 ^^^^^^^^^^^^^ Ref -> `localparam int initial_state = STATE_IDLE`\n\ Expanded from\n\ ``DECLARE_INT(initial_state, STATE_IDLE)`
                                ^^^^^^^^^^ Ref -> `// In test.state_t`\n\\n\---\n\\n\`// Enum for testing macro with enum values\n\typedef enum {\n\    STATE_IDLE = 0,\n\    STATE_ACTIVE = 1,\n\    STATE_WAIT = 2,\n\    STATE_DONE = 3\n\} state_t;`

    `DECLARE_INT(active_state, STATE_ACTIVE)
    ^^^^^^^^^^^^ Ref -> ``define DECLARE_INT(name, val) localparam int name = val;`
                 ^^^^^^^^^^^^ Ref -> `localparam int active_state = STATE_ACTIVE`\n\ Expanded from\n\ ``DECLARE_INT(active_state, STATE_ACTIVE)`
                               ^^^^^^^^^^^^ Ref -> `// In test.state_t`\n\\n\---\n\\n\`// Enum for testing macro with enum values\n\typedef enum {\n\    STATE_IDLE = 0,\n\    STATE_ACTIVE = 1,\n\    STATE_WAIT = 2,\n\    STATE_DONE = 3\n\} state_t;`



    `INFO(some_int + other_int)



    localparam int x = some_int;
                   ^ Sym x : Parameter
                       ^^^^^^^^ Ref -> `localparam int some_int = 1`\n\ Expanded from\n\ ``DECLARE_INT(some_int, 1)`





    // Test macro in generate blocks

    genvar i;
           ^ Sym i : Genvar

    generate

        for (i = 0; i < `SIMPLE_MACRO; i++) begin : gen_block
                    ^ Ref -> `// In test`\n\\n\---\n\\n\`i`
                        ^^^^^^^^^^^^^ Ref -> `// Basic macro definitions\n\`define SIMPLE_MACRO 42`
                                       ^ Ref -> `// In test`\n\\n\---\n\\n\`i`
                                                    ^^^^^^^^^ Sym gen_block : GenerateBlockArray

            logic [`FUNC_MACRO(7):0] gen_signal;
                   ^^^^^^^^^^^ Ref -> ``define FUNC_MACRO(x) (x + 1)`
                                     ^^^^^^^^^^ Sym gen_signal : Variable

        end

    endgenerate



    // Test macro in always blocks

    always_comb begin

        case (test_var)
              ^^^^^^^^ Ref -> `// Variables for testing - use macros from common_macros.svh\n\int test_var;`

            `SIMPLE_MACRO: bus_signal = `TWO_ARG_MACRO(1, 2);
            ^^^^^^^^^^^^^ Ref -> `// Basic macro definitions\n\`define SIMPLE_MACRO 42`
                           ^^^^^^^^^^ Ref -> `logic [-1:0] bus_signal;`
                                        ^^^^^^^^^^^^^^ Ref -> ``define TWO_ARG_MACRO(a, b) (a + b)`

            default: bus_signal = `FUNC_MACRO(0);
                     ^^^^^^^^^^ Ref -> `logic [-1:0] bus_signal;`
                                  ^^^^^^^^^^^ Ref -> ``define FUNC_MACRO(x) (x + 1)`

        endcase

    end





    // Signals for memory instantiation

    logic clk, rst_n, write_enable;
          ^^^ Sym clk : Variable
               ^^^^^ Sym rst_n : Variable
                      ^^^^^^^^^^^^ Sym write_enable : Variable

    logic [31:0] write_data, read_data;
                 ^^^^^^^^^^ Sym write_data : Variable
                             ^^^^^^^^^ Sym read_data : Variable



    // Test ifdef/else conditional compilation

`ifdef USE_MEMORY_MODULE

    // Use the macro to instantiate memory_module

    `INST_MEMORY(mem_inst, 32)

`else

    // Alternative implementation without memory_module

    test_struct my_struct;
    ^^^^^^^^^^^ Ref -> `// Basic struct for testing member access\n\typedef struct {\n\    int i;\n\    logic [7:0] data;\n\} test_struct;`
                ^^^^^^^^^ Sym my_struct : Variable

`endif



    // Test macro with system tasks

    initial begin

        $display("Testing macro: %d", `SIMPLE_MACRO);
                                      ^^^^^^^^^^^^^ Ref -> `// Basic macro definitions\n\`define SIMPLE_MACRO 42`

        $display("Function macro result: %d", `FUNC_MACRO(25));
                                              ^^^^^^^^^^^ Ref -> ``define FUNC_MACRO(x) (x + 1)`

        $display("Max value: %d", `MAX(10, 20));
                                  ^^^^ Ref -> `// From common_macros.svh`\n\\n\---\n\\n\``define MAX(a, b) ((a) > (b) ? (a) : (b))`

        $display("Min value: %d", `MIN(10, 20));
                                  ^^^^ Ref -> `// From common_macros.svh`\n\\n\---\n\\n\``define MIN(a, b) ((a) < (b) ? (a) : (b))`



        // Test assertion macro from common_macros.svh

        `ASSERT_EQ(10, 10)
        ^^^^^^^^^^ Ref -> `// From common_macros.svh`\n\\n\---\n\\n\``define ASSERT_EQ(actual, expected) \\n\if (actual !== expected) \\n\    $error("Assertion failed: %s != %s", `"actual`", `"expected`");`

    end



endmodule
