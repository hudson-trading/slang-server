
package test_pkg;
        ^^^^^^^^ Sym test_pkg : Package

    parameter int WIDTH = 32;
                  ^^^^^ Sym WIDTH : Parameter

    typedef logic [WIDTH-1:0] id_t;
                   ^^^^^ Ref -> **Parameter** `WIDTH` in `test_pkg`  \n\Type: `int`  \n\Value: `32`  \n\\n\\n\---\n\\n\`parameter int WIDTH = 32`
                              ^^^^ Sym id_t : TypeAlias



    typedef struct packed {

        id_t id;
        ^^^^ Ref -> **TypeAlias** `id_t` in `test_pkg`  \n\Resolved Type: `id_t` (aka `logic[31:0]`)  \n\Resolved Width: `32`  \n\\n\\n\---\n\\n\`typedef logic [WIDTH-1:0] id_t;`
             ^^ Sym id : Field

        logic [15:0] data;
                     ^^^^ Sym data : Field

    } packet_t;
      ^^^^^^^^ Sym packet_t : TypeAlias



    typedef enum logic [1:0] {

        STATE_A,
        ^^^^^^^ Sym STATE_A : EnumValue

        STATE_B,
        ^^^^^^^ Sym STATE_B : EnumValue

        STATE_C
        ^^^^^^^ Sym STATE_C : EnumValue

    } state_t;
      ^^^^^^^ Sym state_t : TypeAlias



    parameter type data_t = logic [7:0];
                   ^^^^^^ Sym data_t : TypeAlias

endpackage



interface bus_if #(
          ^^^^^^ Sym bus_if : Definition

    parameter type data_t,
                   ^^^^^^ Sym data_t : TypeAlias

    parameter int ADDR_WIDTH = 32
                  ^^^^^^^^^^ Sym ADDR_WIDTH : Parameter

)(

    input logic clk,
                ^^^ Sym clk : Variable

    input logic rst
                ^^^ Sym rst : Variable

);



    logic valid;
          ^^^^^ Sym valid : Variable

    logic ready;
          ^^^^^ Sym ready : Variable

    logic [ADDR_WIDTH-1:0] addr;
           ^^^^^^^^^^ Ref -> **Parameter** `ADDR_WIDTH` in `bus_if`  \n\Type: `int`  \n\\n\\n\---\n\\n\`parameter int ADDR_WIDTH = 32`
                           ^^^^ Sym addr : Variable

    data_t data;
    ^^^^^^ Ref -> **TypeAlias** `data_t` in `bus_if`  \n\\n\\n\---\n\\n\`parameter type data_t`
           ^^^^ Sym data : Variable

    logic write_enable;
          ^^^^^^^^^^^^ Sym write_enable : Variable



    // Modport for master

    modport master (
            ^^^^^^ Sym master : Modport

        input clk, rst, ready,
              ^^^ Sym clk : ModportPort
                   ^^^ Sym rst : ModportPort
                        ^^^^^ Sym ready : ModportPort

        output valid, addr, data, write_enable
               ^^^^^ Sym valid : ModportPort
                      ^^^^ Sym addr : ModportPort
                            ^^^^ Sym data : ModportPort
                                  ^^^^^^^^^^^^ Sym write_enable : ModportPort

    );



    // Modport for follower

    modport follower (
            ^^^^^^^^ Sym follower : Modport

        input clk, rst, valid, addr, data, write_enable,
              ^^^ Sym clk : ModportPort
                   ^^^ Sym rst : ModportPort
                        ^^^^^ Sym valid : ModportPort
                               ^^^^ Sym addr : ModportPort
                                     ^^^^ Sym data : ModportPort
                                           ^^^^^^^^^^^^ Sym write_enable : ModportPort

        output ready
               ^^^^^ Sym ready : ModportPort

    );



    // Task for master to write data

    task automatic write_data(input logic [ADDR_WIDTH-1:0] address, input data_t write_data);
                   ^^^^^^^^^^ Sym write_data : Subroutine
                                           ^^^^^^^^^^ Ref -> **Parameter** `ADDR_WIDTH` in `bus_if`  \n\Type: `int`  \n\\n\\n\---\n\\n\`parameter int ADDR_WIDTH = 32`
                                                           ^^^^^^^ Sym address : FormalArgument
                                                                          ^^^^^^ Ref -> **TypeAlias** `data_t` in `bus_if`  \n\\n\\n\---\n\\n\`parameter type data_t`
                                                                                 ^^^^^^^^^^ Sym write_data : FormalArgument

        @(posedge clk);
                  ^^^ Ref -> **Variable** `clk` in `bus_if`  \n\Type: `logic`  \n\\n\\n\---\n\\n\`input logic clk`

        addr <= address;
        ^^^^ Ref -> **Variable** `addr` in `bus_if`  \n\Type: Incomplete type  \n\\n\\n\---\n\\n\`logic [ADDR_WIDTH-1:0] addr;`
                ^^^^^^^ Ref -> **FormalArgument** `address` in `bus_if.write_data`  \n\Type: Incomplete type  \n\\n\\n\---\n\\n\`input logic [ADDR_WIDTH-1:0] address`

        data <= write_data;
        ^^^^ Ref -> **Variable** `data` in `bus_if`  \n\Type: Incomplete type  \n\\n\\n\---\n\\n\`data_t data;`
                ^^^^^^^^^^ Ref -> **FormalArgument** `write_data` in `bus_if.write_data`  \n\Type: Incomplete type  \n\\n\\n\---\n\\n\`input data_t write_data`

        write_enable <= 1'b1;
        ^^^^^^^^^^^^ Ref -> **Variable** `write_enable` in `bus_if`  \n\Type: `logic`  \n\\n\\n\---\n\\n\`logic write_enable;`

        valid <= 1'b1;
        ^^^^^ Ref -> **Variable** `valid` in `bus_if`  \n\Type: `logic`  \n\\n\\n\---\n\\n\`logic valid;`

        @(posedge clk iff ready);
                  ^^^ Ref -> **Variable** `clk` in `bus_if`  \n\Type: `logic`  \n\\n\\n\---\n\\n\`input logic clk`
                          ^^^^^ Ref -> **Variable** `ready` in `bus_if`  \n\Type: `logic`  \n\\n\\n\---\n\\n\`logic ready;`

        valid <= 1'b0;
        ^^^^^ Ref -> **Variable** `valid` in `bus_if`  \n\Type: `logic`  \n\\n\\n\---\n\\n\`logic valid;`

        write_enable <= 1'b0;
        ^^^^^^^^^^^^ Ref -> **Variable** `write_enable` in `bus_if`  \n\Type: `logic`  \n\\n\\n\---\n\\n\`logic write_enable;`

    endtask



    // Task for master to read data

    task automatic read_data(input logic [ADDR_WIDTH-1:0] address, output data_t read_data);
                   ^^^^^^^^^ Sym read_data : Subroutine
                                          ^^^^^^^^^^ Ref -> **Parameter** `ADDR_WIDTH` in `bus_if`  \n\Type: `int`  \n\\n\\n\---\n\\n\`parameter int ADDR_WIDTH = 32`
                                                          ^^^^^^^ Sym address : FormalArgument
                                                                          ^^^^^^ Ref -> **TypeAlias** `data_t` in `bus_if`  \n\\n\\n\---\n\\n\`parameter type data_t`
                                                                                 ^^^^^^^^^ Sym read_data : FormalArgument

        @(posedge clk);
                  ^^^ Ref -> **Variable** `clk` in `bus_if`  \n\Type: `logic`  \n\\n\\n\---\n\\n\`input logic clk`

        addr <= address;
        ^^^^ Ref -> **Variable** `addr` in `bus_if`  \n\Type: Incomplete type  \n\\n\\n\---\n\\n\`logic [ADDR_WIDTH-1:0] addr;`
                ^^^^^^^ Ref -> **FormalArgument** `address` in `bus_if.read_data`  \n\Type: Incomplete type  \n\\n\\n\---\n\\n\`input logic [ADDR_WIDTH-1:0] address`

        write_enable <= 1'b0;
        ^^^^^^^^^^^^ Ref -> **Variable** `write_enable` in `bus_if`  \n\Type: `logic`  \n\\n\\n\---\n\\n\`logic write_enable;`

        valid <= 1'b1;
        ^^^^^ Ref -> **Variable** `valid` in `bus_if`  \n\Type: `logic`  \n\\n\\n\---\n\\n\`logic valid;`

        @(posedge clk iff ready);
                  ^^^ Ref -> **Variable** `clk` in `bus_if`  \n\Type: `logic`  \n\\n\\n\---\n\\n\`input logic clk`
                          ^^^^^ Ref -> **Variable** `ready` in `bus_if`  \n\Type: `logic`  \n\\n\\n\---\n\\n\`logic ready;`

        read_data = data;
        ^^^^^^^^^ Ref -> **FormalArgument** `read_data` in `bus_if.read_data`  \n\Type: Incomplete type  \n\\n\\n\---\n\\n\`output data_t read_data`
                    ^^^^ Ref -> **Variable** `data` in `bus_if`  \n\Type: Incomplete type  \n\\n\\n\---\n\\n\`data_t data;`

        valid <= 1'b0;
        ^^^^^ Ref -> **Variable** `valid` in `bus_if`  \n\Type: `logic`  \n\\n\\n\---\n\\n\`logic valid;`

    endtask



endinterface



module Sub #(
       ^^^ Sym Sub : Definition

    parameter int WIDTH = 16
                  ^^^^^ Sym WIDTH : Parameter

)(

    input logic clk,
                ^^^ Sym clk : Variable

    input logic rst,
                ^^^ Sym rst : Variable

    input logic [WIDTH-1:0] data_in,
                 ^^^^^ Ref -> **Parameter** `WIDTH` in `Sub`  \n\Type: `int`  \n\\n\\n\---\n\\n\`parameter int WIDTH = 16`
                            ^^^^^^^ Sym data_in : Variable

    output logic [WIDTH-1:0] data_out
                  ^^^^^ Ref -> **Parameter** `WIDTH` in `Sub`  \n\Type: `int`  \n\\n\\n\---\n\\n\`parameter int WIDTH = 16`
                             ^^^^^^^^ Sym data_out : Variable

);



    always_ff @(posedge clk or posedge rst) begin
                        ^^^ Ref -> **Variable** `clk` in `Sub`  \n\Type: `logic`  \n\\n\\n\---\n\\n\`input logic clk`
                                       ^^^ Ref -> **Variable** `rst` in `Sub`  \n\Type: `logic`  \n\\n\\n\---\n\\n\`input logic rst`

        if (rst) begin
            ^^^ Ref -> **Variable** `rst` in `Sub`  \n\Type: `logic`  \n\\n\\n\---\n\\n\`input logic rst`

            data_out <= '0;
            ^^^^^^^^ Ref -> **Variable** `data_out` in `Sub`  \n\Type: Incomplete type  \n\\n\\n\---\n\\n\`output logic [WIDTH-1:0] data_out`

        end else begin

            data_out <= data_in;
            ^^^^^^^^ Ref -> **Variable** `data_out` in `Sub`  \n\Type: Incomplete type  \n\\n\\n\---\n\\n\`output logic [WIDTH-1:0] data_out`
                        ^^^^^^^ Ref -> **Variable** `data_in` in `Sub`  \n\Type: Incomplete type  \n\\n\\n\---\n\\n\`input logic [WIDTH-1:0] data_in`

        end

    end



endmodule



module TestModule #(
       ^^^^^^^^^^ Sym TestModule : Definition

    parameter int NUM_SUBS = 4
                  ^^^^^^^^ Sym NUM_SUBS : Parameter

)(

    input logic clk,
                ^^^ Sym clk : Variable

    input logic rst,
                ^^^ Sym rst : Variable

    // some useful info

    input logic          [test_pkg::WIDTH-1:0] width_port,
                          ^^^^^^^^ Ref -> **Package** `test_pkg`  \n\\n\\n\---\n\\n\`package test_pkg;`
                                    ^^^^^ Ref -> **Parameter** `WIDTH` in `test_pkg`  \n\Type: `int`  \n\Value: `32`  \n\\n\\n\---\n\\n\`parameter int WIDTH = 32`
                                               ^^^^^^^^^^ Sym width_port : Variable

    input test_pkg::id_t [test_pkg::WIDTH-1:0] id_array,
          ^^^^^^^^ Ref -> **Package** `test_pkg`  \n\\n\\n\---\n\\n\`package test_pkg;`
                    ^^^^ Ref -> **TypeAlias** `id_t` in `test_pkg`  \n\Resolved Type: `id_t` (aka `logic[31:0]`)  \n\Resolved Width: `32`  \n\\n\\n\---\n\\n\`typedef logic [WIDTH-1:0] id_t;`
                          ^^^^^^^^ Ref -> **Package** `test_pkg`  \n\\n\\n\---\n\\n\`package test_pkg;`
                                    ^^^^^ Ref -> **Parameter** `WIDTH` in `test_pkg`  \n\Type: `int`  \n\Value: `32`  \n\\n\\n\---\n\\n\`parameter int WIDTH = 32`
                                               ^^^^^^^^ Sym id_array : Variable

    input test_pkg::packet_t pkt_in,
          ^^^^^^^^ Ref -> **Package** `test_pkg`  \n\\n\\n\---\n\\n\`package test_pkg;`
                    ^^^^^^^^ Ref -> **TypeAlias** `packet_t` in `test_pkg`  \n\Resolved Type: PackedStruct `packet_t` (`logic[47:0]`)  \n\Resolved Width: `48`  \n\\n\\n\---\n\\n\`typedef struct packed {\n\    id_t id;\n\    logic [15:0] data;\n\} packet_t;`
                             ^^^^^^ Sym pkt_in : Variable

    output test_pkg::data_t data_out,
           ^^^^^^^^ Ref -> **Package** `test_pkg`  \n\\n\\n\---\n\\n\`package test_pkg;`
                     ^^^^^^ Ref -> **TypeAlias** `data_t` in `test_pkg`  \n\Resolved Type: `data_t` (aka `logic[7:0]`)  \n\Resolved Width: `8`  \n\\n\\n\---\n\\n\`parameter type data_t = logic [7:0]`
                            ^^^^^^^^ Sym data_out : Variable

    bus_if.master bus_master,
    ^^^^^^ Ref -> **Definition** `bus_if`  \n\\n\\n\---\n\\n\`interface bus_if #(\n\    parameter type data_t,\n\    parameter int ADDR_WIDTH = 32\n\)(\n\    input logic clk,\n\    input logic rst\n\);`
           ^ Ref -> **Modport** `master` in `bus_if`  \n\\n\\n\---\n\\n\`// Modport for master\n\modport master (\n\    input clk, rst, ready,\n\    output valid, addr, data, write_enable\n\);`
            ^ Ref -> **Modport** `master` in `bus_if`  \n\\n\\n\---\n\\n\`// Modport for master\n\modport master (\n\    input clk, rst, ready,\n\    output valid, addr, data, write_enable\n\);`
             ^ Ref -> **Modport** `master` in `bus_if`  \n\\n\\n\---\n\\n\`// Modport for master\n\modport master (\n\    input clk, rst, ready,\n\    output valid, addr, data, write_enable\n\);`
              ^ Ref -> **Modport** `master` in `bus_if`  \n\\n\\n\---\n\\n\`// Modport for master\n\modport master (\n\    input clk, rst, ready,\n\    output valid, addr, data, write_enable\n\);`
               ^ Ref -> **Modport** `master` in `bus_if`  \n\\n\\n\---\n\\n\`// Modport for master\n\modport master (\n\    input clk, rst, ready,\n\    output valid, addr, data, write_enable\n\);`
                ^ Ref -> **Modport** `master` in `bus_if`  \n\\n\\n\---\n\\n\`// Modport for master\n\modport master (\n\    input clk, rst, ready,\n\    output valid, addr, data, write_enable\n\);`
                  ^^^^^^^^^^ Sym bus_master : InterfacePort

    bus_if.follower bus_follower
    ^^^^^^ Ref -> **Definition** `bus_if`  \n\\n\\n\---\n\\n\`interface bus_if #(\n\    parameter type data_t,\n\    parameter int ADDR_WIDTH = 32\n\)(\n\    input logic clk,\n\    input logic rst\n\);`
           ^ Ref -> **Modport** `follower` in `bus_if`  \n\\n\\n\---\n\\n\`// Modport for follower\n\modport follower (\n\    input clk, rst, valid, addr, data, write_enable,\n\    output ready\n\);`
            ^ Ref -> **Modport** `follower` in `bus_if`  \n\\n\\n\---\n\\n\`// Modport for follower\n\modport follower (\n\    input clk, rst, valid, addr, data, write_enable,\n\    output ready\n\);`
             ^ Ref -> **Modport** `follower` in `bus_if`  \n\\n\\n\---\n\\n\`// Modport for follower\n\modport follower (\n\    input clk, rst, valid, addr, data, write_enable,\n\    output ready\n\);`
              ^ Ref -> **Modport** `follower` in `bus_if`  \n\\n\\n\---\n\\n\`// Modport for follower\n\modport follower (\n\    input clk, rst, valid, addr, data, write_enable,\n\    output ready\n\);`
               ^ Ref -> **Modport** `follower` in `bus_if`  \n\\n\\n\---\n\\n\`// Modport for follower\n\modport follower (\n\    input clk, rst, valid, addr, data, write_enable,\n\    output ready\n\);`
                ^ Ref -> **Modport** `follower` in `bus_if`  \n\\n\\n\---\n\\n\`// Modport for follower\n\modport follower (\n\    input clk, rst, valid, addr, data, write_enable,\n\    output ready\n\);`
                 ^ Ref -> **Modport** `follower` in `bus_if`  \n\\n\\n\---\n\\n\`// Modport for follower\n\modport follower (\n\    input clk, rst, valid, addr, data, write_enable,\n\    output ready\n\);`
                  ^ Ref -> **Modport** `follower` in `bus_if`  \n\\n\\n\---\n\\n\`// Modport for follower\n\modport follower (\n\    input clk, rst, valid, addr, data, write_enable,\n\    output ready\n\);`
                    ^^^^^^^^^^^^ Sym bus_follower : InterfacePort

);



    test_pkg::state_t state, state_next;
    ^^^^^^^^ Ref -> **Package** `test_pkg`  \n\\n\\n\---\n\\n\`package test_pkg;`
              ^^^^^^^ Ref -> **TypeAlias** `state_t` in `test_pkg`  \n\Resolved Type: Enum `state_t` (`logic[1:0]`)  \n\Resolved Width: `2`  \n\\n\\n\---\n\\n\`typedef enum logic [1:0] {\n\    STATE_A,\n\    STATE_B,\n\    STATE_C\n\} state_t;`
                      ^^^^^ Sym state : Variable
                             ^^^^^^^^^^ Sym state_next : Variable

    test_pkg::id_t counter;
    ^^^^^^^^ Ref -> **Package** `test_pkg`  \n\\n\\n\---\n\\n\`package test_pkg;`
              ^^^^ Ref -> **TypeAlias** `id_t` in `test_pkg`  \n\Resolved Type: `id_t` (aka `logic[31:0]`)  \n\Resolved Width: `32`  \n\\n\\n\---\n\\n\`typedef logic [WIDTH-1:0] id_t;`
                   ^^^^^^^ Sym counter : Variable



    // Instance array that depends on NUM_SUBS parameter

    logic [15:0] sub_data_in [NUM_SUBS];
                 ^^^^^^^^^^^ Sym sub_data_in : Variable
                              ^^^^^^^^ Ref -> **Parameter** `NUM_SUBS` in `TestModule`  \n\Type: `int`  \n\Value: `4`  \n\\n\\n\---\n\\n\`parameter int NUM_SUBS = 4`

    logic [15:0] sub_data_out [NUM_SUBS];
                 ^^^^^^^^^^^^ Sym sub_data_out : Variable
                               ^^^^^^^^ Ref -> **Parameter** `NUM_SUBS` in `TestModule`  \n\Type: `int`  \n\Value: `4`  \n\\n\\n\---\n\\n\`parameter int NUM_SUBS = 4`



    Sub #(.WIDTH(16)) sub_inst [NUM_SUBS] (
    ^^^ Ref -> **Definition** `Sub`  \n\\n\\n\---\n\\n\`module Sub #(\n\    parameter int WIDTH = 16\n\)(\n\    input logic clk,\n\    input logic rst,\n\    input logic [WIDTH-1:0] data_in,\n\    output logic [WIDTH-1:0] data_out\n\);`
           ^^^^^ Ref -> **Parameter** `WIDTH` in `Sub`  \n\Type: `int`  \n\Value: `16`  \n\\n\\n\---\n\\n\`parameter int WIDTH = 16`
                      ^^^^^^^^ Sym sub_inst : InstanceArray
                                ^^^^^^^^ Ref -> **Parameter** `NUM_SUBS` in `TestModule`  \n\Type: `int`  \n\Value: `4`  \n\\n\\n\---\n\\n\`parameter int NUM_SUBS = 4`

        .clk(clk),
         ^^^ Ref -> **Variable** `clk` in `Sub`  \n\Type: `logic`  \n\\n\\n\---\n\\n\`input logic clk`
             ^^^ Ref -> **Variable** `clk` in `TestModule`  \n\Type: `logic`  \n\\n\\n\---\n\\n\`input logic clk`

        .rst(rst),
         ^^^ Ref -> **Variable** `rst` in `Sub`  \n\Type: `logic`  \n\\n\\n\---\n\\n\`input logic rst`
             ^^^ Ref -> **Variable** `rst` in `TestModule`  \n\Type: `logic`  \n\\n\\n\---\n\\n\`input logic rst`

        .data_in(sub_data_in),
         ^^^^^^^ Ref -> **Variable** `data_in` in `Sub`  \n\Type: `logic[15:0]`  \n\Width: `16`  \n\\n\\n\---\n\\n\`input logic [WIDTH-1:0] data_in`
                 ^^^^^^^^^^^ Ref -> **Variable** `sub_data_in` in `TestModule`  \n\Type: `unpacked array [4] of logic[15:0]`  \n\\n\\n\---\n\\n\`// Instance array that depends on NUM_SUBS parameter\n\logic [15:0] sub_data_in [NUM_SUBS];`

        .data_out(sub_data_out)
         ^^^^^^^^ Ref -> **Variable** `data_out` in `Sub`  \n\Type: `logic[15:0]`  \n\Width: `16`  \n\\n\\n\---\n\\n\`output logic [WIDTH-1:0] data_out`
                  ^^^^^^^^^^^^ Ref -> **Variable** `sub_data_out` in `TestModule`  \n\Type: `unpacked array [4] of logic[15:0]`  \n\\n\\n\---\n\\n\`logic [15:0] sub_data_out [NUM_SUBS];`

    );



    // Test instance array access - goto on sub_inst[0] should go to sub_inst declaration

    logic [15:0] inst_array_test;
                 ^^^^^^^^^^^^^^^ Sym inst_array_test : Variable

    assign inst_array_test = sub_inst[0].data_out + sub_inst[1].data_out;
           ^^^^^^^^^^^^^^^ Ref -> **Variable** `inst_array_test` in `TestModule`  \n\Type: `logic[15:0]`  \n\Width: `16`  \n\\n\\n\---\n\\n\`// Test instance array access - goto on sub_inst[0] should go to sub_inst declaration\n\logic [15:0] inst_array_test;`
                             ^^^^^^^^ Ref -> **Instance** `` in `TestModule.sub_inst`  \n\Type: Sub  \n\\n\\n\---\n\\n\`Sub #(.WIDTH(16)) sub_inst [NUM_SUBS] (\n\    .clk(clk),\n\    .rst(rst),\n\    .data_in(sub_data_in),\n\    .data_out(sub_data_out)\n\);`
                                         ^^^^^^^^ Ref -> **Variable** `data_out` in `Sub`  \n\Type: `logic[15:0]`  \n\Width: `16`  \n\\n\\n\---\n\\n\`output logic [WIDTH-1:0] data_out`
                                                    ^^^^^^^^ Ref -> **Instance** `` in `TestModule.sub_inst`  \n\Type: Sub  \n\\n\\n\---\n\\n\`Sub #(.WIDTH(16)) sub_inst [NUM_SUBS] (\n\    .clk(clk),\n\    .rst(rst),\n\    .data_in(sub_data_in),\n\    .data_out(sub_data_out)\n\);`
                                                                ^^^^^^^^ Ref -> **Variable** `data_out` in `Sub`  \n\Type: `logic[15:0]`  \n\Width: `16`  \n\\n\\n\---\n\\n\`output logic [WIDTH-1:0] data_out`



    always_ff @(posedge clk) begin
                        ^^^ Ref -> **Variable** `clk` in `TestModule`  \n\Type: `logic`  \n\\n\\n\---\n\\n\`input logic clk`

        if (rst) begin
            ^^^ Ref -> **Variable** `rst` in `TestModule`  \n\Type: `logic`  \n\\n\\n\---\n\\n\`input logic rst`

            state <= test_pkg::STATE_A;
            ^^^^^ Ref -> **Variable** `state` in `TestModule`  \n\Type: Enum `state_t` (`logic[1:0]`)  \n\Width: `2`  \n\\n\\n\---\n\\n\`test_pkg::state_t state, state_next;`
                     ^^^^^^^^ Ref -> **Package** `test_pkg`  \n\\n\\n\---\n\\n\`package test_pkg;`
                               ^^^^^^^ Ref -> **EnumValue** `STATE_A` in `test_pkg::state_t`  \n\Value: `2'b0`  \n\\n\\n\---\n\\n\`typedef enum logic [1:0] {\n\    STATE_A,\n\    STATE_B,\n\    STATE_C\n\} state_t;`

            counter <= '0;
            ^^^^^^^ Ref -> **Variable** `counter` in `TestModule`  \n\Type: `id_t` (aka `logic[31:0]`)  \n\Width: `32`  \n\\n\\n\---\n\\n\`test_pkg::id_t counter;`

        end else begin

            state <= state_next;
            ^^^^^ Ref -> **Variable** `state` in `TestModule`  \n\Type: Enum `state_t` (`logic[1:0]`)  \n\Width: `2`  \n\\n\\n\---\n\\n\`test_pkg::state_t state, state_next;`
                     ^^^^^^^^^^ Ref -> **Variable** `state_next` in `TestModule`  \n\Type: Enum `state_t` (`logic[1:0]`)  \n\Width: `2`  \n\\n\\n\---\n\\n\`test_pkg::state_t state, state_next;`

            counter <= counter + 1'b1;
            ^^^^^^^ Ref -> **Variable** `counter` in `TestModule`  \n\Type: `id_t` (aka `logic[31:0]`)  \n\Width: `32`  \n\\n\\n\---\n\\n\`test_pkg::id_t counter;`
                       ^^^^^^^ Ref -> **Variable** `counter` in `TestModule`  \n\Type: `id_t` (aka `logic[31:0]`)  \n\Width: `32`  \n\\n\\n\---\n\\n\`test_pkg::id_t counter;`

        end

    end



    always_comb begin

        case (state)
              ^^^^^ Ref -> **Variable** `state` in `TestModule`  \n\Type: Enum `state_t` (`logic[1:0]`)  \n\Width: `2`  \n\\n\\n\---\n\\n\`test_pkg::state_t state, state_next;`

            test_pkg::STATE_A: state_next = test_pkg::STATE_B;
            ^^^^^^^^ Ref -> **Package** `test_pkg`  \n\\n\\n\---\n\\n\`package test_pkg;`
                      ^^^^^^^ Ref -> **EnumValue** `STATE_A` in `test_pkg::state_t`  \n\Value: `2'b0`  \n\\n\\n\---\n\\n\`typedef enum logic [1:0] {\n\    STATE_A,\n\    STATE_B,\n\    STATE_C\n\} state_t;`
                               ^^^^^^^^^^ Ref -> **Variable** `state_next` in `TestModule`  \n\Type: Enum `state_t` (`logic[1:0]`)  \n\Width: `2`  \n\\n\\n\---\n\\n\`test_pkg::state_t state, state_next;`
                                            ^^^^^^^^ Ref -> **Package** `test_pkg`  \n\\n\\n\---\n\\n\`package test_pkg;`
                                                      ^^^^^^^ Ref -> **EnumValue** `STATE_B` in `test_pkg::state_t`  \n\Value: `2'b1`  \n\\n\\n\---\n\\n\`typedef enum logic [1:0] {\n\    STATE_A,\n\    STATE_B,\n\    STATE_C\n\} state_t;`

            test_pkg::STATE_B: state_next = test_pkg::STATE_C;
            ^^^^^^^^ Ref -> **Package** `test_pkg`  \n\\n\\n\---\n\\n\`package test_pkg;`
                      ^^^^^^^ Ref -> **EnumValue** `STATE_B` in `test_pkg::state_t`  \n\Value: `2'b1`  \n\\n\\n\---\n\\n\`typedef enum logic [1:0] {\n\    STATE_A,\n\    STATE_B,\n\    STATE_C\n\} state_t;`
                               ^^^^^^^^^^ Ref -> **Variable** `state_next` in `TestModule`  \n\Type: Enum `state_t` (`logic[1:0]`)  \n\Width: `2`  \n\\n\\n\---\n\\n\`test_pkg::state_t state, state_next;`
                                            ^^^^^^^^ Ref -> **Package** `test_pkg`  \n\\n\\n\---\n\\n\`package test_pkg;`
                                                      ^^^^^^^ Ref -> **EnumValue** `STATE_C` in `test_pkg::state_t`  \n\Value: `2'b10`  \n\\n\\n\---\n\\n\`typedef enum logic [1:0] {\n\    STATE_A,\n\    STATE_B,\n\    STATE_C\n\} state_t;`

            default: state_next = test_pkg::STATE_A;
                     ^^^^^^^^^^ Ref -> **Variable** `state_next` in `TestModule`  \n\Type: Enum `state_t` (`logic[1:0]`)  \n\Width: `2`  \n\\n\\n\---\n\\n\`test_pkg::state_t state, state_next;`
                                  ^^^^^^^^ Ref -> **Package** `test_pkg`  \n\\n\\n\---\n\\n\`package test_pkg;`
                                            ^^^^^^^ Ref -> **EnumValue** `STATE_A` in `test_pkg::state_t`  \n\Value: `2'b0`  \n\\n\\n\---\n\\n\`typedef enum logic [1:0] {\n\    STATE_A,\n\    STATE_B,\n\    STATE_C\n\} state_t;`

        endcase

    end



    // Use the bus interfaces

    always_ff @(posedge clk) begin
                        ^^^ Ref -> **Variable** `clk` in `TestModule`  \n\Type: `logic`  \n\\n\\n\---\n\\n\`input logic clk`

        if (rst) begin
            ^^^ Ref -> **Variable** `rst` in `TestModule`  \n\Type: `logic`  \n\\n\\n\---\n\\n\`input logic rst`

            data_out <= '0;
            ^^^^^^^^ Ref -> **Variable** `data_out` in `TestModule`  \n\Type: `data_t` (aka `logic[7:0]`)  \n\Width: `8`  \n\\n\\n\---\n\\n\`output test_pkg::data_t data_out`

            bus_follower.ready <= 1'b0;
            ^^^^^^^^^^^^ Ref -> **InterfacePort** `bus_follower` in `TestModule`  \n\\n\\n\---\n\\n\`bus_if.follower bus_follower`
                         ^^^^^ Ref -> **ModportPort** `ready` in `bus_if.follower`  \n\Type: `logic`  \n\\n\\n\---\n\\n\`output ready`

        end else begin

            // Simple follower logic - always ready, echo data

            bus_follower.ready <= 1'b1;
            ^^^^^^^^^^^^ Ref -> **InterfacePort** `bus_follower` in `TestModule`  \n\\n\\n\---\n\\n\`bus_if.follower bus_follower`
                         ^^^^^ Ref -> **ModportPort** `ready` in `bus_if.follower`  \n\Type: `logic`  \n\\n\\n\---\n\\n\`output ready`

            if (bus_follower.valid && bus_follower.write_enable) begin
                ^^^^^^^^^^^^ Ref -> **InterfacePort** `bus_follower` in `TestModule`  \n\\n\\n\---\n\\n\`bus_if.follower bus_follower`
                             ^^^^^ Ref -> **ModportPort** `valid` in `bus_if.follower`  \n\Type: `logic`  \n\\n\\n\---\n\\n\`input clk, rst, valid, addr, data, write_enable`
                                      ^^^^^^^^^^^^ Ref -> **InterfacePort** `bus_follower` in `TestModule`  \n\\n\\n\---\n\\n\`bus_if.follower bus_follower`
                                                   ^^^^^^^^^^^^ Ref -> **ModportPort** `write_enable` in `bus_if.follower`  \n\Type: `logic`  \n\\n\\n\---\n\\n\`input clk, rst, valid, addr, data, write_enable`

                data_out <= bus_follower.data[7:0]; // Convert to data_t size
                ^^^^^^^^ Ref -> **Variable** `data_out` in `TestModule`  \n\Type: `data_t` (aka `logic[7:0]`)  \n\Width: `8`  \n\\n\\n\---\n\\n\`output test_pkg::data_t data_out`
                            ^^^^^^^^^^^^ Ref -> **InterfacePort** `bus_follower` in `TestModule`  \n\\n\\n\---\n\\n\`bus_if.follower bus_follower`
                                         ^^^^ Ref -> **ModportPort** `data` in `bus_if.follower`  \n\Type: Incomplete type  \n\\n\\n\---\n\\n\`input clk, rst, valid, addr, data, write_enable`

            end

        end

    end



    // Master interface usage example

    initial begin

        bus_master.valid <= 1'b0;
        ^^^^^^^^^^ Ref -> **InterfacePort** `bus_master` in `TestModule`  \n\\n\\n\---\n\\n\`bus_if.master bus_master`
                   ^^^^^ Ref -> **ModportPort** `valid` in `bus_if.master`  \n\Type: `logic`  \n\\n\\n\---\n\\n\`output valid, addr, data, write_enable`

        bus_master.write_enable <= 1'b0;
        ^^^^^^^^^^ Ref -> **InterfacePort** `bus_master` in `TestModule`  \n\\n\\n\---\n\\n\`bus_if.master bus_master`
                   ^^^^^^^^^^^^ Ref -> **ModportPort** `write_enable` in `bus_if.master`  \n\Type: `logic`  \n\\n\\n\---\n\\n\`output valid, addr, data, write_enable`

        bus_master.addr = width_port[0];
        ^^^^^^^^^^ Ref -> **InterfacePort** `bus_master` in `TestModule`  \n\\n\\n\---\n\\n\`bus_if.master bus_master`
                   ^^^^ Ref -> **ModportPort** `addr` in `bus_if.master`  \n\Type: `logic[31:0]`  \n\Width: `32`  \n\\n\\n\---\n\\n\`output valid, addr, data, write_enable`
                          ^^^^^^^^^^ Ref -> **Variable** `width_port` in `TestModule`  \n\Type: `logic[31:0]`  \n\Width: `32`  \n\\n\\n\---\n\\n\`// some useful info\n\input logic [test_pkg::WIDTH-1:0] width_port`

        bus_master.data <= state;
        ^^^^^^^^^^ Ref -> **InterfacePort** `bus_master` in `TestModule`  \n\\n\\n\---\n\\n\`bus_if.master bus_master`
                   ^^^^ Ref -> **ModportPort** `data` in `bus_if.master`  \n\Type: Incomplete type  \n\\n\\n\---\n\\n\`output valid, addr, data, write_enable`
                           ^^^^^ Ref -> **Variable** `state` in `TestModule`  \n\Type: Enum `state_t` (`logic[1:0]`)  \n\Width: `2`  \n\\n\\n\---\n\\n\`test_pkg::state_t state, state_next;`



    end



endmodule





module NoDefaults #(
       ^^^^^^^^^^ Sym NoDefaults : Definition

    parameter int WIDTH,
                  ^^^^^ Sym WIDTH : Parameter

    parameter int n_iters,
                  ^^^^^^^ Sym n_iters : Parameter

    parameter bit gen_branch = 0
                  ^^^^^^^^^^ Sym gen_branch : Parameter

)(

    input logic clk,
                ^^^ Sym clk : Variable

    input logic rst,
                ^^^ Sym rst : Variable

    input logic [WIDTH-1:0] data_in,
                 ^^^^^ Ref -> **Parameter** `WIDTH` in `NoDefaults`  \n\Type: `int`  \n\\n\\n\---\n\\n\`parameter int WIDTH`
                            ^^^^^^^ Sym data_in : Variable

    output logic [WIDTH-1:0] data_out
                  ^^^^^ Ref -> **Parameter** `WIDTH` in `NoDefaults`  \n\Type: `int`  \n\\n\\n\---\n\\n\`parameter int WIDTH`
                             ^^^^^^^^ Sym data_out : Variable

);



    Sub #(
    ^^^ Ref -> **Definition** `Sub`  \n\\n\\n\---\n\\n\`module Sub #(\n\    parameter int WIDTH = 16\n\)(\n\    input logic clk,\n\    input logic rst,\n\    input logic [WIDTH-1:0] data_in,\n\    output logic [WIDTH-1:0] data_out\n\);`

        .WIDTH(WIDTH)
         ^^^^^ Ref -> **Parameter** `WIDTH` in `Sub`  \n\Type: `int`  \n\\n\\n\---\n\\n\`parameter int WIDTH = 16`
               ^^^^^ Ref -> **Parameter** `WIDTH` in `NoDefaults`  \n\Type: `int`  \n\\n\\n\---\n\\n\`parameter int WIDTH`

    ) sub_inst (
      ^^^^^^^^ Sym sub_inst : Instance

        .clk(clk),
         ^^^ Ref -> **Variable** `clk` in `Sub`  \n\Type: `logic`  \n\\n\\n\---\n\\n\`input logic clk`
             ^^^ Ref -> **Variable** `clk` in `NoDefaults`  \n\Type: `logic`  \n\\n\\n\---\n\\n\`input logic clk`

        .rst(rst),
         ^^^ Ref -> **Variable** `rst` in `Sub`  \n\Type: `logic`  \n\\n\\n\---\n\\n\`input logic rst`
             ^^^ Ref -> **Variable** `rst` in `NoDefaults`  \n\Type: `logic`  \n\\n\\n\---\n\\n\`input logic rst`

        .data_in(data_in),
         ^^^^^^^ Ref -> **Variable** `data_in` in `Sub`  \n\Type: Incomplete type  \n\\n\\n\---\n\\n\`input logic [WIDTH-1:0] data_in`
                 ^^^^^^^ Ref -> **Variable** `data_in` in `NoDefaults`  \n\Type: Incomplete type  \n\\n\\n\---\n\\n\`input logic [WIDTH-1:0] data_in`

        .data_out(data_out)
         ^^^^^^^^ Ref -> **Variable** `data_out` in `Sub`  \n\Type: Incomplete type  \n\\n\\n\---\n\\n\`output logic [WIDTH-1:0] data_out`
                  ^^^^^^^^ Ref -> **Variable** `data_out` in `NoDefaults`  \n\Type: Incomplete type  \n\\n\\n\---\n\\n\`output logic [WIDTH-1:0] data_out`

    );



    // 2D instance array

    Sub #(.WIDTH(WIDTH)) sub_2d [2][3] (
    ^^^ Ref -> **Definition** `Sub`  \n\\n\\n\---\n\\n\`module Sub #(\n\    parameter int WIDTH = 16\n\)(\n\    input logic clk,\n\    input logic rst,\n\    input logic [WIDTH-1:0] data_in,\n\    output logic [WIDTH-1:0] data_out\n\);`
           ^^^^^ Ref -> **Parameter** `WIDTH` in `Sub`  \n\Type: `int`  \n\\n\\n\---\n\\n\`parameter int WIDTH = 16`
                 ^^^^^ Ref -> **Parameter** `WIDTH` in `NoDefaults`  \n\Type: `int`  \n\\n\\n\---\n\\n\`parameter int WIDTH`
                         ^^^^^^ Sym sub_2d : InstanceArray

        .clk(clk),
         ^^^ Ref -> **Variable** `clk` in `Sub`  \n\Type: `logic`  \n\\n\\n\---\n\\n\`input logic clk`
             ^^^ Ref -> **Variable** `clk` in `NoDefaults`  \n\Type: `logic`  \n\\n\\n\---\n\\n\`input logic clk`

        .rst(rst),
         ^^^ Ref -> **Variable** `rst` in `Sub`  \n\Type: `logic`  \n\\n\\n\---\n\\n\`input logic rst`
             ^^^ Ref -> **Variable** `rst` in `NoDefaults`  \n\Type: `logic`  \n\\n\\n\---\n\\n\`input logic rst`

        .data_in(data_in),
         ^^^^^^^ Ref -> **Variable** `data_in` in `Sub`  \n\Type: Incomplete type  \n\\n\\n\---\n\\n\`input logic [WIDTH-1:0] data_in`
                 ^^^^^^^ Ref -> **Variable** `data_in` in `NoDefaults`  \n\Type: Incomplete type  \n\\n\\n\---\n\\n\`input logic [WIDTH-1:0] data_in`

        .data_out()
         ^^^^^^^^ Ref -> **Variable** `data_out` in `Sub`  \n\Type: Incomplete type  \n\\n\\n\---\n\\n\`output logic [WIDTH-1:0] data_out`

    );



    // Test 2D instance array access

    logic [WIDTH-1:0] test_2d_access;
           ^^^^^ Ref -> **Parameter** `WIDTH` in `NoDefaults`  \n\Type: `int`  \n\\n\\n\---\n\\n\`parameter int WIDTH`
                      ^^^^^^^^^^^^^^ Sym test_2d_access : Variable

    assign test_2d_access = sub_2d[0][1].data_out + sub_2d[1][2].data_out;
           ^^^^^^^^^^^^^^ Ref -> **Variable** `test_2d_access` in `NoDefaults`  \n\Type: Incomplete type  \n\\n\\n\---\n\\n\`// Test 2D instance array access\n\logic [WIDTH-1:0] test_2d_access;`
                            ^^^^^^ Ref -> **Instance** `` in `NoDefaults.sub_2d`  \n\Type: Sub  \n\\n\\n\---\n\\n\`// 2D instance array\n\Sub #(.WIDTH(WIDTH)) sub_2d [2][3] (\n\    .clk(clk),\n\    .rst(rst),\n\    .data_in(data_in),\n\    .data_out()\n\);`
                                         ^^^^^^^^ Ref -> **Variable** `data_out` in `Sub`  \n\Type: Incomplete type  \n\\n\\n\---\n\\n\`output logic [WIDTH-1:0] data_out`
                                                    ^^^^^^ Ref -> **Instance** `` in `NoDefaults.sub_2d`  \n\Type: Sub  \n\\n\\n\---\n\\n\`// 2D instance array\n\Sub #(.WIDTH(WIDTH)) sub_2d [2][3] (\n\    .clk(clk),\n\    .rst(rst),\n\    .data_in(data_in),\n\    .data_out()\n\);`
                                                                 ^^^^^^^^ Ref -> **Variable** `data_out` in `Sub`  \n\Type: Incomplete type  \n\\n\\n\---\n\\n\`output logic [WIDTH-1:0] data_out`



    genvar j;
           ^ Sym j : Genvar

    for(j = 0; j < 3; j++) begin : gen_loop_2
               ^ Ref -> **Genvar** `j` in `NoDefaults`  \n\\n\\n\---\n\\n\`j`
                      ^ Ref -> **Genvar** `j` in `NoDefaults`  \n\\n\\n\---\n\\n\`j`
                                   ^^^^^^^^^^ Sym gen_loop_2 : GenerateBlockArray

        Sub #(.WIDTH(WIDTH)) gen_sub_array [4] (
        ^^^ Ref -> **Definition** `Sub`  \n\\n\\n\---\n\\n\`module Sub #(\n\    parameter int WIDTH = 16\n\)(\n\    input logic clk,\n\    input logic rst,\n\    input logic [WIDTH-1:0] data_in,\n\    output logic [WIDTH-1:0] data_out\n\);`
               ^^^^^ Ref -> **Parameter** `WIDTH` in `Sub`  \n\Type: `int`  \n\\n\\n\---\n\\n\`parameter int WIDTH = 16`
                     ^^^^^ Ref -> **Parameter** `WIDTH` in `NoDefaults`  \n\Type: `int`  \n\\n\\n\---\n\\n\`parameter int WIDTH`
                             ^^^^^^^^^^^^^ Sym gen_sub_array : InstanceArray

            .clk(clk),
             ^^^ Ref -> **Variable** `clk` in `Sub`  \n\Type: `logic`  \n\\n\\n\---\n\\n\`input logic clk`
                 ^^^ Ref -> **Variable** `clk` in `NoDefaults`  \n\Type: `logic`  \n\\n\\n\---\n\\n\`input logic clk`

            .rst(rst),
             ^^^ Ref -> **Variable** `rst` in `Sub`  \n\Type: `logic`  \n\\n\\n\---\n\\n\`input logic rst`
                 ^^^ Ref -> **Variable** `rst` in `NoDefaults`  \n\Type: `logic`  \n\\n\\n\---\n\\n\`input logic rst`

            .data_in(data_in),
             ^^^^^^^ Ref -> **Variable** `data_in` in `Sub`  \n\Type: Incomplete type  \n\\n\\n\---\n\\n\`input logic [WIDTH-1:0] data_in`
                     ^^^^^^^ Ref -> **Variable** `data_in` in `NoDefaults`  \n\Type: Incomplete type  \n\\n\\n\---\n\\n\`input logic [WIDTH-1:0] data_in`

            .data_out()
             ^^^^^^^^ Ref -> **Variable** `data_out` in `Sub`  \n\Type: Incomplete type  \n\\n\\n\---\n\\n\`output logic [WIDTH-1:0] data_out`

        );

    end



    // Test instance array inside generate scope access

    logic [WIDTH-1:0] test_gen_array_access;
           ^^^^^ Ref -> **Parameter** `WIDTH` in `NoDefaults`  \n\Type: `int`  \n\\n\\n\---\n\\n\`parameter int WIDTH`
                      ^^^^^^^^^^^^^^^^^^^^^ Sym test_gen_array_access : Variable

    assign test_gen_array_access = gen_loop_2[0].gen_sub_array[2].data_out;
           ^^^^^^^^^^^^^^^^^^^^^ Ref -> **Variable** `test_gen_array_access` in `NoDefaults`  \n\Type: Incomplete type  \n\\n\\n\---\n\\n\`// Test instance array inside generate scope access\n\logic [WIDTH-1:0] test_gen_array_access;`
                                   ^^^^^^^^^^ Ref -> **GenerateBlock** `` in `NoDefaults.gen_loop_2`  \n\\n\\n\---\n\\n\`begin : gen_loop_2\n\    Sub #(.WIDTH(WIDTH)) gen_sub_array [4] (\n\        .clk(clk),\n\        .rst(rst),\n\        .data_in(data_in),\n\        .data_out()\n\    );\n\end`
                                                 ^^^^^^^^^^^^^ Ref -> **Instance** `` in `NoDefaults.gen_loop_2.gen_sub_array`  \n\Type: Sub  \n\\n\\n\---\n\\n\`Sub #(.WIDTH(WIDTH)) gen_sub_array [4] (\n\    .clk(clk),\n\    .rst(rst),\n\    .data_in(data_in),\n\    .data_out()\n\);`
                                                                  ^^^^^^^^ Ref -> **Variable** `data_out` in `Sub`  \n\Type: Incomplete type  \n\\n\\n\---\n\\n\`output logic [WIDTH-1:0] data_out`



    genvar i;
           ^ Sym i : Genvar

    for(i = 0; i < n_iters; i++) begin : gen_loop
               ^ Ref -> **Genvar** `i` in `NoDefaults`  \n\\n\\n\---\n\\n\`i`
                   ^^^^^^^ Ref -> **Parameter** `n_iters` in `NoDefaults`  \n\Type: `int`  \n\\n\\n\---\n\\n\`parameter int n_iters`
                            ^ Ref -> **Genvar** `i` in `NoDefaults`  \n\\n\\n\---\n\\n\`i`
                                         ^^^^^^^^ Sym gen_loop : GenerateBlockArray

        Sub #(
        ^^^ Ref -> **Definition** `Sub`  \n\\n\\n\---\n\\n\`module Sub #(\n\    parameter int WIDTH = 16\n\)(\n\    input logic clk,\n\    input logic rst,\n\    input logic [WIDTH-1:0] data_in,\n\    output logic [WIDTH-1:0] data_out\n\);`

            .WIDTH(WIDTH)
             ^^^^^ Ref -> **Parameter** `WIDTH` in `Sub`  \n\Type: `int`  \n\\n\\n\---\n\\n\`parameter int WIDTH = 16`
                   ^^^^^ Ref -> **Parameter** `WIDTH` in `NoDefaults`  \n\Type: `int`  \n\\n\\n\---\n\\n\`parameter int WIDTH`

         ) sub (
           ^^^ Sym sub : Instance

            .clk(clk),
             ^^^ Ref -> **Variable** `clk` in `Sub`  \n\Type: `logic`  \n\\n\\n\---\n\\n\`input logic clk`
                 ^^^ Ref -> **Variable** `clk` in `NoDefaults`  \n\Type: `logic`  \n\\n\\n\---\n\\n\`input logic clk`

            .rst(rst),
             ^^^ Ref -> **Variable** `rst` in `Sub`  \n\Type: `logic`  \n\\n\\n\---\n\\n\`input logic rst`
                 ^^^ Ref -> **Variable** `rst` in `NoDefaults`  \n\Type: `logic`  \n\\n\\n\---\n\\n\`input logic rst`

            .data_in(data_in),
             ^^^^^^^ Ref -> **Variable** `data_in` in `Sub`  \n\Type: Incomplete type  \n\\n\\n\---\n\\n\`input logic [WIDTH-1:0] data_in`
                     ^^^^^^^ Ref -> **Variable** `data_in` in `NoDefaults`  \n\Type: Incomplete type  \n\\n\\n\---\n\\n\`input logic [WIDTH-1:0] data_in`

            .data_out(data_out)
             ^^^^^^^^ Ref -> **Variable** `data_out` in `Sub`  \n\Type: Incomplete type  \n\\n\\n\---\n\\n\`output logic [WIDTH-1:0] data_out`
                      ^^^^^^^^ Ref -> **Variable** `data_out` in `NoDefaults`  \n\Type: Incomplete type  \n\\n\\n\---\n\\n\`output logic [WIDTH-1:0] data_out`

        );

    end



    if (gen_branch) begin : gen_branch_block
        ^^^^^^^^^^ Ref -> **Parameter** `gen_branch` in `NoDefaults`  \n\Type: `bit`  \n\Value: `1'b0`  \n\\n\\n\---\n\\n\`parameter bit gen_branch = 0`
                            ^^^^^^^^^^^^^^^^ Sym gen_branch_block : GenerateBlock

        Sub #(
        ^^^ Ref -> **Definition** `Sub`  \n\\n\\n\---\n\\n\`module Sub #(\n\    parameter int WIDTH = 16\n\)(\n\    input logic clk,\n\    input logic rst,\n\    input logic [WIDTH-1:0] data_in,\n\    output logic [WIDTH-1:0] data_out\n\);`

            .WIDTH(WIDTH)
             ^^^^^ Ref -> **Parameter** `WIDTH` in `Sub`  \n\Type: `int`  \n\\n\\n\---\n\\n\`parameter int WIDTH = 16`
                   ^^^^^ Ref -> **Parameter** `WIDTH` in `NoDefaults`  \n\Type: `int`  \n\\n\\n\---\n\\n\`parameter int WIDTH`

        ) sub_branch (
          ^^^^^^^^^^ Sym sub_branch : Instance

            .clk(clk),
             ^^^ Ref -> **Variable** `clk` in `Sub`  \n\Type: `logic`  \n\\n\\n\---\n\\n\`input logic clk`
                 ^^^ Ref -> **Variable** `clk` in `NoDefaults`  \n\Type: `logic`  \n\\n\\n\---\n\\n\`input logic clk`

            .rst(rst),
             ^^^ Ref -> **Variable** `rst` in `Sub`  \n\Type: `logic`  \n\\n\\n\---\n\\n\`input logic rst`
                 ^^^ Ref -> **Variable** `rst` in `NoDefaults`  \n\Type: `logic`  \n\\n\\n\---\n\\n\`input logic rst`

            .data_in(data_in),
             ^^^^^^^ Ref -> **Variable** `data_in` in `Sub`  \n\Type: Incomplete type  \n\\n\\n\---\n\\n\`input logic [WIDTH-1:0] data_in`
                     ^^^^^^^ Ref -> **Variable** `data_in` in `NoDefaults`  \n\Type: Incomplete type  \n\\n\\n\---\n\\n\`input logic [WIDTH-1:0] data_in`

            .data_out(data_out)
             ^^^^^^^^ Ref -> **Variable** `data_out` in `Sub`  \n\Type: Incomplete type  \n\\n\\n\---\n\\n\`output logic [WIDTH-1:0] data_out`
                      ^^^^^^^^ Ref -> **Variable** `data_out` in `NoDefaults`  \n\Type: Incomplete type  \n\\n\\n\---\n\\n\`output logic [WIDTH-1:0] data_out`

        );

    end else begin : gen_no_branch_block
                     ^^^^^^^^^^^^^^^^^^^ Sym gen_no_branch_block : GenerateBlock

        Sub #(
        ^^^ Ref -> **Definition** `Sub`  \n\\n\\n\---\n\\n\`module Sub #(\n\    parameter int WIDTH = 16\n\)(\n\    input logic clk,\n\    input logic rst,\n\    input logic [WIDTH-1:0] data_in,\n\    output logic [WIDTH-1:0] data_out\n\);`

            .WIDTH(WIDTH)
             ^^^^^ Ref -> **Parameter** `WIDTH` in `Sub`  \n\Type: `int`  \n\\n\\n\---\n\\n\`parameter int WIDTH = 16`
                   ^^^^^ Ref -> **Parameter** `WIDTH` in `NoDefaults`  \n\Type: `int`  \n\\n\\n\---\n\\n\`parameter int WIDTH`

        ) sub_no_branch (
          ^^^^^^^^^^^^^ Sym sub_no_branch : Instance

            .clk(clk),
             ^^^ Ref -> **Variable** `clk` in `Sub`  \n\Type: `logic`  \n\\n\\n\---\n\\n\`input logic clk`
                 ^^^ Ref -> **Variable** `clk` in `NoDefaults`  \n\Type: `logic`  \n\\n\\n\---\n\\n\`input logic clk`

            .rst(rst),
             ^^^ Ref -> **Variable** `rst` in `Sub`  \n\Type: `logic`  \n\\n\\n\---\n\\n\`input logic rst`
                 ^^^ Ref -> **Variable** `rst` in `NoDefaults`  \n\Type: `logic`  \n\\n\\n\---\n\\n\`input logic rst`

            .data_in(data_in),
             ^^^^^^^ Ref -> **Variable** `data_in` in `Sub`  \n\Type: Incomplete type  \n\\n\\n\---\n\\n\`input logic [WIDTH-1:0] data_in`
                     ^^^^^^^ Ref -> **Variable** `data_in` in `NoDefaults`  \n\Type: Incomplete type  \n\\n\\n\---\n\\n\`input logic [WIDTH-1:0] data_in`

            .data_out(data_out)
             ^^^^^^^^ Ref -> **Variable** `data_out` in `Sub`  \n\Type: Incomplete type  \n\\n\\n\---\n\\n\`output logic [WIDTH-1:0] data_out`
                      ^^^^^^^^ Ref -> **Variable** `data_out` in `NoDefaults`  \n\Type: Incomplete type  \n\\n\\n\---\n\\n\`output logic [WIDTH-1:0] data_out`

        );

    end



endmodule



module StructAssignmentTest (
       ^^^^^^^^^^^^^^^^^^^^ Sym StructAssignmentTest : Definition

    input logic clk,
                ^^^ Sym clk : Variable

    input logic rst
                ^^^ Sym rst : Variable

);



    // Struct definitions for testing

    typedef struct packed {

        logic [7:0] addr;
                    ^^^^ Sym addr : Field

        logic [15:0] data;
                     ^^^^ Sym data : Field

        logic valid;
              ^^^^^ Sym valid : Field

    } simple_struct_t;
      ^^^^^^^^^^^^^^^ Sym simple_struct_t : TypeAlias



    typedef struct packed {

        simple_struct_t inner;
        ^^^^^^^^^^^^^^^ Ref -> **TypeAlias** `simple_struct_t` in `StructAssignmentTest`  \n\Resolved Type: PackedStruct `simple_struct_t` (`logic[24:0]`)  \n\Resolved Width: `25`  \n\\n\\n\---\n\\n\`// Struct definitions for testing\n\typedef struct packed {\n\    logic [7:0] addr;\n\    logic [15:0] data;\n\    logic valid;\n\} simple_struct_t;`
                        ^^^^^ Sym inner : Field

        logic [3:0] tag;
                    ^^^ Sym tag : Field

        logic enable;
              ^^^^^^ Sym enable : Field

    } nested_struct_t;
      ^^^^^^^^^^^^^^^ Sym nested_struct_t : TypeAlias



    // Variables for testing

    simple_struct_t single_struct;
    ^^^^^^^^^^^^^^^ Ref -> **TypeAlias** `simple_struct_t` in `StructAssignmentTest`  \n\Resolved Type: PackedStruct `simple_struct_t` (`logic[24:0]`)  \n\Resolved Width: `25`  \n\\n\\n\---\n\\n\`// Struct definitions for testing\n\typedef struct packed {\n\    logic [7:0] addr;\n\    logic [15:0] data;\n\    logic valid;\n\} simple_struct_t;`
                    ^^^^^^^^^^^^^ Sym single_struct : Variable

    simple_struct_t struct_array[4];
    ^^^^^^^^^^^^^^^ Ref -> **TypeAlias** `simple_struct_t` in `StructAssignmentTest`  \n\Resolved Type: PackedStruct `simple_struct_t` (`logic[24:0]`)  \n\Resolved Width: `25`  \n\\n\\n\---\n\\n\`// Struct definitions for testing\n\typedef struct packed {\n\    logic [7:0] addr;\n\    logic [15:0] data;\n\    logic valid;\n\} simple_struct_t;`
                    ^^^^^^^^^^^^ Sym struct_array : Variable

    nested_struct_t nested_struct;
    ^^^^^^^^^^^^^^^ Ref -> **TypeAlias** `nested_struct_t` in `StructAssignmentTest`  \n\Resolved Type: PackedStruct `nested_struct_t` (`logic[29:0]`)  \n\Resolved Width: `30`  \n\\n\\n\---\n\\n\`typedef struct packed {\n\    simple_struct_t inner;\n\    logic [3:0] tag;\n\    logic enable;\n\} nested_struct_t;`
                    ^^^^^^^^^^^^^ Sym nested_struct : Variable

    nested_struct_t nested_array[2];
    ^^^^^^^^^^^^^^^ Ref -> **TypeAlias** `nested_struct_t` in `StructAssignmentTest`  \n\Resolved Type: PackedStruct `nested_struct_t` (`logic[29:0]`)  \n\Resolved Width: `30`  \n\\n\\n\---\n\\n\`typedef struct packed {\n\    simple_struct_t inner;\n\    logic [3:0] tag;\n\    logic enable;\n\} nested_struct_t;`
                    ^^^^^^^^^^^^ Sym nested_array : Variable

    test_pkg::packet_t pkg_struct;
    ^^^^^^^^ Ref -> **Package** `test_pkg`  \n\\n\\n\---\n\\n\`package test_pkg;`
              ^^^^^^^^ Ref -> **TypeAlias** `packet_t` in `test_pkg`  \n\Resolved Type: PackedStruct `packet_t` (`logic[47:0]`)  \n\Resolved Width: `48`  \n\\n\\n\---\n\\n\`typedef struct packed {\n\    id_t id;\n\    logic [15:0] data;\n\} packet_t;`
                       ^^^^^^^^^^ Sym pkg_struct : Variable

    test_pkg::packet_t pkg_array[3];
    ^^^^^^^^ Ref -> **Package** `test_pkg`  \n\\n\\n\---\n\\n\`package test_pkg;`
              ^^^^^^^^ Ref -> **TypeAlias** `packet_t` in `test_pkg`  \n\Resolved Type: PackedStruct `packet_t` (`logic[47:0]`)  \n\Resolved Width: `48`  \n\\n\\n\---\n\\n\`typedef struct packed {\n\    id_t id;\n\    logic [15:0] data;\n\} packet_t;`
                       ^^^^^^^^^ Sym pkg_array : Variable



    logic [1:0] index;
                ^^^^^ Sym index : Variable

    logic [7:0] addr_val;
                ^^^^^^^^ Sym addr_val : Variable

    logic [15:0] data_val;
                 ^^^^^^^^ Sym data_val : Variable



    always_ff @(posedge clk) begin
                        ^^^ Ref -> **Variable** `clk` in `StructAssignmentTest`  \n\Type: `logic`  \n\\n\\n\---\n\\n\`input logic clk`

        if (rst) begin
            ^^^ Ref -> **Variable** `rst` in `StructAssignmentTest`  \n\Type: `logic`  \n\\n\\n\---\n\\n\`input logic rst`

            // Basic struct member assignment

            single_struct.addr <= 8'h00;
            ^^^^^^^^^^^^^ Ref -> **Variable** `single_struct` in `StructAssignmentTest`  \n\Type: PackedStruct `simple_struct_t` (`logic[24:0]`)  \n\Width: `25`  \n\\n\\n\---\n\\n\`// Variables for testing\n\simple_struct_t single_struct;`
                          ^^^^ Ref -> **Field** `addr` in `StructAssignmentTest::simple_struct_t`  \n\Type: `logic[7:0]`  \n\Width: `8`  \n\\n\\n\---\n\\n\`logic [7:0] addr;`

            single_struct.data <= 16'h0000;
            ^^^^^^^^^^^^^ Ref -> **Variable** `single_struct` in `StructAssignmentTest`  \n\Type: PackedStruct `simple_struct_t` (`logic[24:0]`)  \n\Width: `25`  \n\\n\\n\---\n\\n\`// Variables for testing\n\simple_struct_t single_struct;`
                          ^^^^ Ref -> **Field** `data` in `StructAssignmentTest::simple_struct_t`  \n\Type: `logic[15:0]`  \n\Width: `16`  \n\\n\\n\---\n\\n\`logic [15:0] data;`

            single_struct.valid <= 1'b0;
            ^^^^^^^^^^^^^ Ref -> **Variable** `single_struct` in `StructAssignmentTest`  \n\Type: PackedStruct `simple_struct_t` (`logic[24:0]`)  \n\Width: `25`  \n\\n\\n\---\n\\n\`// Variables for testing\n\simple_struct_t single_struct;`
                          ^^^^^ Ref -> **Field** `valid` in `StructAssignmentTest::simple_struct_t`  \n\Type: `logic`  \n\\n\\n\---\n\\n\`logic valid;`



            // Array index struct member assignment

            struct_array[0].addr <= 8'hAA;
            ^^^^^^^^^^^^ Ref -> **Variable** `struct_array` in `StructAssignmentTest`  \n\Type: `unpacked array [4] of simple_struct_t`  \n\\n\\n\---\n\\n\`simple_struct_t struct_array[4];`
                            ^^^^ Ref -> **Field** `addr` in `StructAssignmentTest::simple_struct_t`  \n\Type: `logic[7:0]`  \n\Width: `8`  \n\\n\\n\---\n\\n\`logic [7:0] addr;`

            struct_array[1].data <= 16'hBBBB;
            ^^^^^^^^^^^^ Ref -> **Variable** `struct_array` in `StructAssignmentTest`  \n\Type: `unpacked array [4] of simple_struct_t`  \n\\n\\n\---\n\\n\`simple_struct_t struct_array[4];`
                            ^^^^ Ref -> **Field** `data` in `StructAssignmentTest::simple_struct_t`  \n\Type: `logic[15:0]`  \n\Width: `16`  \n\\n\\n\---\n\\n\`logic [15:0] data;`

            struct_array[2].valid <= 1'b1;
            ^^^^^^^^^^^^ Ref -> **Variable** `struct_array` in `StructAssignmentTest`  \n\Type: `unpacked array [4] of simple_struct_t`  \n\\n\\n\---\n\\n\`simple_struct_t struct_array[4];`
                            ^^^^^ Ref -> **Field** `valid` in `StructAssignmentTest::simple_struct_t`  \n\Type: `logic`  \n\\n\\n\---\n\\n\`logic valid;`



            // Variable index struct member assignment

            struct_array[index].addr <= 8'hCC;
            ^^^^^^^^^^^^ Ref -> **Variable** `struct_array` in `StructAssignmentTest`  \n\Type: `unpacked array [4] of simple_struct_t`  \n\\n\\n\---\n\\n\`simple_struct_t struct_array[4];`
                         ^^^^^ Ref -> **Variable** `index` in `StructAssignmentTest`  \n\Type: `logic[1:0]`  \n\Width: `2`  \n\\n\\n\---\n\\n\`logic [1:0] index;`
                                ^^^^ Ref -> **Field** `addr` in `StructAssignmentTest::simple_struct_t`  \n\Type: `logic[7:0]`  \n\Width: `8`  \n\\n\\n\---\n\\n\`logic [7:0] addr;`

            struct_array[index].data <= data_val;
            ^^^^^^^^^^^^ Ref -> **Variable** `struct_array` in `StructAssignmentTest`  \n\Type: `unpacked array [4] of simple_struct_t`  \n\\n\\n\---\n\\n\`simple_struct_t struct_array[4];`
                         ^^^^^ Ref -> **Variable** `index` in `StructAssignmentTest`  \n\Type: `logic[1:0]`  \n\Width: `2`  \n\\n\\n\---\n\\n\`logic [1:0] index;`
                                ^^^^ Ref -> **Field** `data` in `StructAssignmentTest::simple_struct_t`  \n\Type: `logic[15:0]`  \n\Width: `16`  \n\\n\\n\---\n\\n\`logic [15:0] data;`
                                        ^^^^^^^^ Ref -> **Variable** `data_val` in `StructAssignmentTest`  \n\Type: `logic[15:0]`  \n\Width: `16`  \n\\n\\n\---\n\\n\`logic [15:0] data_val;`



            // Nested struct member assignment

            nested_struct.inner.addr <= 8'hDD;
            ^^^^^^^^^^^^^ Ref -> **Variable** `nested_struct` in `StructAssignmentTest`  \n\Type: PackedStruct `nested_struct_t` (`logic[29:0]`)  \n\Width: `30`  \n\\n\\n\---\n\\n\`nested_struct_t nested_struct;`
                          ^^^^^ Ref -> **Field** `inner` in `StructAssignmentTest::nested_struct_t`  \n\Type: PackedStruct `simple_struct_t` (`logic[24:0]`)  \n\Width: `25`  \n\\n\\n\---\n\\n\`simple_struct_t inner;`
                                ^^^^ Ref -> **Field** `addr` in `StructAssignmentTest::simple_struct_t`  \n\Type: `logic[7:0]`  \n\Width: `8`  \n\\n\\n\---\n\\n\`logic [7:0] addr;`

            nested_struct.inner.data <= 16'hEEEE;
            ^^^^^^^^^^^^^ Ref -> **Variable** `nested_struct` in `StructAssignmentTest`  \n\Type: PackedStruct `nested_struct_t` (`logic[29:0]`)  \n\Width: `30`  \n\\n\\n\---\n\\n\`nested_struct_t nested_struct;`
                          ^^^^^ Ref -> **Field** `inner` in `StructAssignmentTest::nested_struct_t`  \n\Type: PackedStruct `simple_struct_t` (`logic[24:0]`)  \n\Width: `25`  \n\\n\\n\---\n\\n\`simple_struct_t inner;`
                                ^^^^ Ref -> **Field** `data` in `StructAssignmentTest::simple_struct_t`  \n\Type: `logic[15:0]`  \n\Width: `16`  \n\\n\\n\---\n\\n\`logic [15:0] data;`

            nested_struct.inner.valid <= 1'b0;
            ^^^^^^^^^^^^^ Ref -> **Variable** `nested_struct` in `StructAssignmentTest`  \n\Type: PackedStruct `nested_struct_t` (`logic[29:0]`)  \n\Width: `30`  \n\\n\\n\---\n\\n\`nested_struct_t nested_struct;`
                          ^^^^^ Ref -> **Field** `inner` in `StructAssignmentTest::nested_struct_t`  \n\Type: PackedStruct `simple_struct_t` (`logic[24:0]`)  \n\Width: `25`  \n\\n\\n\---\n\\n\`simple_struct_t inner;`
                                ^^^^^ Ref -> **Field** `valid` in `StructAssignmentTest::simple_struct_t`  \n\Type: `logic`  \n\\n\\n\---\n\\n\`logic valid;`

            nested_struct.tag <= 4'h5;
            ^^^^^^^^^^^^^ Ref -> **Variable** `nested_struct` in `StructAssignmentTest`  \n\Type: PackedStruct `nested_struct_t` (`logic[29:0]`)  \n\Width: `30`  \n\\n\\n\---\n\\n\`nested_struct_t nested_struct;`
                          ^^^ Ref -> **Field** `tag` in `StructAssignmentTest::nested_struct_t`  \n\Type: `logic[3:0]`  \n\Width: `4`  \n\\n\\n\---\n\\n\`logic [3:0] tag;`

            nested_struct.enable <= 1'b1;
            ^^^^^^^^^^^^^ Ref -> **Variable** `nested_struct` in `StructAssignmentTest`  \n\Type: PackedStruct `nested_struct_t` (`logic[29:0]`)  \n\Width: `30`  \n\\n\\n\---\n\\n\`nested_struct_t nested_struct;`
                          ^^^^^^ Ref -> **Field** `enable` in `StructAssignmentTest::nested_struct_t`  \n\Type: `logic`  \n\\n\\n\---\n\\n\`logic enable;`



            // Nested struct array assignment

            nested_array[0].inner.addr <= 8'hFF;
            ^^^^^^^^^^^^ Ref -> **Variable** `nested_array` in `StructAssignmentTest`  \n\Type: `unpacked array [2] of nested_struct_t`  \n\\n\\n\---\n\\n\`nested_struct_t nested_array[2];`
                            ^^^^^ Ref -> **Field** `inner` in `StructAssignmentTest::nested_struct_t`  \n\Type: PackedStruct `simple_struct_t` (`logic[24:0]`)  \n\Width: `25`  \n\\n\\n\---\n\\n\`simple_struct_t inner;`
                                  ^^^^ Ref -> **Field** `addr` in `StructAssignmentTest::simple_struct_t`  \n\Type: `logic[7:0]`  \n\Width: `8`  \n\\n\\n\---\n\\n\`logic [7:0] addr;`

            nested_array[1].inner.data <= 16'h1234;
            ^^^^^^^^^^^^ Ref -> **Variable** `nested_array` in `StructAssignmentTest`  \n\Type: `unpacked array [2] of nested_struct_t`  \n\\n\\n\---\n\\n\`nested_struct_t nested_array[2];`
                            ^^^^^ Ref -> **Field** `inner` in `StructAssignmentTest::nested_struct_t`  \n\Type: PackedStruct `simple_struct_t` (`logic[24:0]`)  \n\Width: `25`  \n\\n\\n\---\n\\n\`simple_struct_t inner;`
                                  ^^^^ Ref -> **Field** `data` in `StructAssignmentTest::simple_struct_t`  \n\Type: `logic[15:0]`  \n\Width: `16`  \n\\n\\n\---\n\\n\`logic [15:0] data;`

            nested_array[index].tag <= 4'h7;
            ^^^^^^^^^^^^ Ref -> **Variable** `nested_array` in `StructAssignmentTest`  \n\Type: `unpacked array [2] of nested_struct_t`  \n\\n\\n\---\n\\n\`nested_struct_t nested_array[2];`
                         ^^^^^ Ref -> **Variable** `index` in `StructAssignmentTest`  \n\Type: `logic[1:0]`  \n\Width: `2`  \n\\n\\n\---\n\\n\`logic [1:0] index;`
                                ^^^ Ref -> **Field** `tag` in `StructAssignmentTest::nested_struct_t`  \n\Type: `logic[3:0]`  \n\Width: `4`  \n\\n\\n\---\n\\n\`logic [3:0] tag;`



            // Package struct member assignment

            pkg_struct.id <= 32'h123;
            ^^^^^^^^^^ Ref -> **Variable** `pkg_struct` in `StructAssignmentTest`  \n\Type: PackedStruct `packet_t` (`logic[47:0]`)  \n\Width: `48`  \n\\n\\n\---\n\\n\`test_pkg::packet_t pkg_struct;`
                       ^^ Ref -> **Field** `id` in `test_pkg::packet_t`  \n\Type: `id_t` (aka `logic[31:0]`)  \n\Width: `32`  \n\\n\\n\---\n\\n\`id_t id;`

            pkg_struct.data <= 16'h5678;
            ^^^^^^^^^^ Ref -> **Variable** `pkg_struct` in `StructAssignmentTest`  \n\Type: PackedStruct `packet_t` (`logic[47:0]`)  \n\Width: `48`  \n\\n\\n\---\n\\n\`test_pkg::packet_t pkg_struct;`
                       ^^^^ Ref -> **Field** `data` in `test_pkg::packet_t`  \n\Type: `logic[15:0]`  \n\Width: `16`  \n\\n\\n\---\n\\n\`logic [15:0] data;`



            // Package struct array assignment

            pkg_array[0].id <= 32'h456;
            ^^^^^^^^^ Ref -> **Variable** `pkg_array` in `StructAssignmentTest`  \n\Type: `unpacked array [3] of packet_t`  \n\\n\\n\---\n\\n\`test_pkg::packet_t pkg_array[3];`
                         ^^ Ref -> **Field** `id` in `test_pkg::packet_t`  \n\Type: `id_t` (aka `logic[31:0]`)  \n\Width: `32`  \n\\n\\n\---\n\\n\`id_t id;`

            pkg_array[1].data <= 16'h9ABC;
            ^^^^^^^^^ Ref -> **Variable** `pkg_array` in `StructAssignmentTest`  \n\Type: `unpacked array [3] of packet_t`  \n\\n\\n\---\n\\n\`test_pkg::packet_t pkg_array[3];`
                         ^^^^ Ref -> **Field** `data` in `test_pkg::packet_t`  \n\Type: `logic[15:0]`  \n\Width: `16`  \n\\n\\n\---\n\\n\`logic [15:0] data;`

            pkg_array[index].id <= {24'h0, addr_val};
            ^^^^^^^^^ Ref -> **Variable** `pkg_array` in `StructAssignmentTest`  \n\Type: `unpacked array [3] of packet_t`  \n\\n\\n\---\n\\n\`test_pkg::packet_t pkg_array[3];`
                      ^^^^^ Ref -> **Variable** `index` in `StructAssignmentTest`  \n\Type: `logic[1:0]`  \n\Width: `2`  \n\\n\\n\---\n\\n\`logic [1:0] index;`
                             ^^ Ref -> **Field** `id` in `test_pkg::packet_t`  \n\Type: `id_t` (aka `logic[31:0]`)  \n\Width: `32`  \n\\n\\n\---\n\\n\`id_t id;`
                                           ^^^^^^^^ Ref -> **Variable** `addr_val` in `StructAssignmentTest`  \n\Type: `logic[7:0]`  \n\Width: `8`  \n\\n\\n\---\n\\n\`logic [7:0] addr_val;`



            index <= 2'b00;
            ^^^^^ Ref -> **Variable** `index` in `StructAssignmentTest`  \n\Type: `logic[1:0]`  \n\Width: `2`  \n\\n\\n\---\n\\n\`logic [1:0] index;`

            addr_val <= 8'h11;
            ^^^^^^^^ Ref -> **Variable** `addr_val` in `StructAssignmentTest`  \n\Type: `logic[7:0]`  \n\Width: `8`  \n\\n\\n\---\n\\n\`logic [7:0] addr_val;`

            data_val <= 16'h2222;
            ^^^^^^^^ Ref -> **Variable** `data_val` in `StructAssignmentTest`  \n\Type: `logic[15:0]`  \n\Width: `16`  \n\\n\\n\---\n\\n\`logic [15:0] data_val;`

        end else begin

            // Runtime assignments with expressions

            single_struct.addr <= addr_val + 8'h10;
            ^^^^^^^^^^^^^ Ref -> **Variable** `single_struct` in `StructAssignmentTest`  \n\Type: PackedStruct `simple_struct_t` (`logic[24:0]`)  \n\Width: `25`  \n\\n\\n\---\n\\n\`// Variables for testing\n\simple_struct_t single_struct;`
                          ^^^^ Ref -> **Field** `addr` in `StructAssignmentTest::simple_struct_t`  \n\Type: `logic[7:0]`  \n\Width: `8`  \n\\n\\n\---\n\\n\`logic [7:0] addr;`
                                  ^^^^^^^^ Ref -> **Variable** `addr_val` in `StructAssignmentTest`  \n\Type: `logic[7:0]`  \n\Width: `8`  \n\\n\\n\---\n\\n\`logic [7:0] addr_val;`

            single_struct.data <= data_val << 1;
            ^^^^^^^^^^^^^ Ref -> **Variable** `single_struct` in `StructAssignmentTest`  \n\Type: PackedStruct `simple_struct_t` (`logic[24:0]`)  \n\Width: `25`  \n\\n\\n\---\n\\n\`// Variables for testing\n\simple_struct_t single_struct;`
                          ^^^^ Ref -> **Field** `data` in `StructAssignmentTest::simple_struct_t`  \n\Type: `logic[15:0]`  \n\Width: `16`  \n\\n\\n\---\n\\n\`logic [15:0] data;`
                                  ^^^^^^^^ Ref -> **Variable** `data_val` in `StructAssignmentTest`  \n\Type: `logic[15:0]`  \n\Width: `16`  \n\\n\\n\---\n\\n\`logic [15:0] data_val;`

            single_struct.valid <= ~single_struct.valid;
            ^^^^^^^^^^^^^ Ref -> **Variable** `single_struct` in `StructAssignmentTest`  \n\Type: PackedStruct `simple_struct_t` (`logic[24:0]`)  \n\Width: `25`  \n\\n\\n\---\n\\n\`// Variables for testing\n\simple_struct_t single_struct;`
                          ^^^^^ Ref -> **Field** `valid` in `StructAssignmentTest::simple_struct_t`  \n\Type: `logic`  \n\\n\\n\---\n\\n\`logic valid;`
                                    ^^^^^^^^^^^^^ Ref -> **Variable** `single_struct` in `StructAssignmentTest`  \n\Type: PackedStruct `simple_struct_t` (`logic[24:0]`)  \n\Width: `25`  \n\\n\\n\---\n\\n\`// Variables for testing\n\simple_struct_t single_struct;`
                                                  ^^^^^ Ref -> **Field** `valid` in `StructAssignmentTest::simple_struct_t`  \n\Type: `logic`  \n\\n\\n\---\n\\n\`logic valid;`



            // Complex array indexing with struct members

            struct_array[index + 1].addr <= single_struct.addr;
            ^^^^^^^^^^^^ Ref -> **Variable** `struct_array` in `StructAssignmentTest`  \n\Type: `unpacked array [4] of simple_struct_t`  \n\\n\\n\---\n\\n\`simple_struct_t struct_array[4];`
                         ^^^^^ Ref -> **Variable** `index` in `StructAssignmentTest`  \n\Type: `logic[1:0]`  \n\Width: `2`  \n\\n\\n\---\n\\n\`logic [1:0] index;`
                                    ^^^^ Ref -> **Field** `addr` in `StructAssignmentTest::simple_struct_t`  \n\Type: `logic[7:0]`  \n\Width: `8`  \n\\n\\n\---\n\\n\`logic [7:0] addr;`
                                            ^^^^^^^^^^^^^ Ref -> **Variable** `single_struct` in `StructAssignmentTest`  \n\Type: PackedStruct `simple_struct_t` (`logic[24:0]`)  \n\Width: `25`  \n\\n\\n\---\n\\n\`// Variables for testing\n\simple_struct_t single_struct;`
                                                          ^^^^ Ref -> **Field** `addr` in `StructAssignmentTest::simple_struct_t`  \n\Type: `logic[7:0]`  \n\Width: `8`  \n\\n\\n\---\n\\n\`logic [7:0] addr;`

            struct_array[addr_val[1:0]].data <= nested_struct.inner.data;
            ^^^^^^^^^^^^ Ref -> **Variable** `struct_array` in `StructAssignmentTest`  \n\Type: `unpacked array [4] of simple_struct_t`  \n\\n\\n\---\n\\n\`simple_struct_t struct_array[4];`
                         ^^^^^^^^ Ref -> **Variable** `addr_val` in `StructAssignmentTest`  \n\Type: `logic[7:0]`  \n\Width: `8`  \n\\n\\n\---\n\\n\`logic [7:0] addr_val;`
                                        ^^^^ Ref -> **Field** `data` in `StructAssignmentTest::simple_struct_t`  \n\Type: `logic[15:0]`  \n\Width: `16`  \n\\n\\n\---\n\\n\`logic [15:0] data;`
                                                ^^^^^^^^^^^^^ Ref -> **Variable** `nested_struct` in `StructAssignmentTest`  \n\Type: PackedStruct `nested_struct_t` (`logic[29:0]`)  \n\Width: `30`  \n\\n\\n\---\n\\n\`nested_struct_t nested_struct;`
                                                              ^^^^^ Ref -> **Field** `inner` in `StructAssignmentTest::nested_struct_t`  \n\Type: PackedStruct `simple_struct_t` (`logic[24:0]`)  \n\Width: `25`  \n\\n\\n\---\n\\n\`simple_struct_t inner;`
                                                                    ^^^^ Ref -> **Field** `data` in `StructAssignmentTest::simple_struct_t`  \n\Type: `logic[15:0]`  \n\Width: `16`  \n\\n\\n\---\n\\n\`logic [15:0] data;`



            // Chained struct member assignments

            nested_struct.inner.addr <= struct_array[0].addr;
            ^^^^^^^^^^^^^ Ref -> **Variable** `nested_struct` in `StructAssignmentTest`  \n\Type: PackedStruct `nested_struct_t` (`logic[29:0]`)  \n\Width: `30`  \n\\n\\n\---\n\\n\`nested_struct_t nested_struct;`
                          ^^^^^ Ref -> **Field** `inner` in `StructAssignmentTest::nested_struct_t`  \n\Type: PackedStruct `simple_struct_t` (`logic[24:0]`)  \n\Width: `25`  \n\\n\\n\---\n\\n\`simple_struct_t inner;`
                                ^^^^ Ref -> **Field** `addr` in `StructAssignmentTest::simple_struct_t`  \n\Type: `logic[7:0]`  \n\Width: `8`  \n\\n\\n\---\n\\n\`logic [7:0] addr;`
                                        ^^^^^^^^^^^^ Ref -> **Variable** `struct_array` in `StructAssignmentTest`  \n\Type: `unpacked array [4] of simple_struct_t`  \n\\n\\n\---\n\\n\`simple_struct_t struct_array[4];`
                                                        ^^^^ Ref -> **Field** `addr` in `StructAssignmentTest::simple_struct_t`  \n\Type: `logic[7:0]`  \n\Width: `8`  \n\\n\\n\---\n\\n\`logic [7:0] addr;`

            nested_struct.inner.data <= pkg_struct.data;
            ^^^^^^^^^^^^^ Ref -> **Variable** `nested_struct` in `StructAssignmentTest`  \n\Type: PackedStruct `nested_struct_t` (`logic[29:0]`)  \n\Width: `30`  \n\\n\\n\---\n\\n\`nested_struct_t nested_struct;`
                          ^^^^^ Ref -> **Field** `inner` in `StructAssignmentTest::nested_struct_t`  \n\Type: PackedStruct `simple_struct_t` (`logic[24:0]`)  \n\Width: `25`  \n\\n\\n\---\n\\n\`simple_struct_t inner;`
                                ^^^^ Ref -> **Field** `data` in `StructAssignmentTest::simple_struct_t`  \n\Type: `logic[15:0]`  \n\Width: `16`  \n\\n\\n\---\n\\n\`logic [15:0] data;`
                                        ^^^^^^^^^^ Ref -> **Variable** `pkg_struct` in `StructAssignmentTest`  \n\Type: PackedStruct `packet_t` (`logic[47:0]`)  \n\Width: `48`  \n\\n\\n\---\n\\n\`test_pkg::packet_t pkg_struct;`
                                                   ^^^^ Ref -> **Field** `data` in `test_pkg::packet_t`  \n\Type: `logic[15:0]`  \n\Width: `16`  \n\\n\\n\---\n\\n\`logic [15:0] data;`

            nested_struct.inner.valid <= pkg_array[index].id[0];
            ^^^^^^^^^^^^^ Ref -> **Variable** `nested_struct` in `StructAssignmentTest`  \n\Type: PackedStruct `nested_struct_t` (`logic[29:0]`)  \n\Width: `30`  \n\\n\\n\---\n\\n\`nested_struct_t nested_struct;`
                          ^^^^^ Ref -> **Field** `inner` in `StructAssignmentTest::nested_struct_t`  \n\Type: PackedStruct `simple_struct_t` (`logic[24:0]`)  \n\Width: `25`  \n\\n\\n\---\n\\n\`simple_struct_t inner;`
                                ^^^^^ Ref -> **Field** `valid` in `StructAssignmentTest::simple_struct_t`  \n\Type: `logic`  \n\\n\\n\---\n\\n\`logic valid;`
                                         ^^^^^^^^^ Ref -> **Variable** `pkg_array` in `StructAssignmentTest`  \n\Type: `unpacked array [3] of packet_t`  \n\\n\\n\---\n\\n\`test_pkg::packet_t pkg_array[3];`
                                                   ^^^^^ Ref -> **Variable** `index` in `StructAssignmentTest`  \n\Type: `logic[1:0]`  \n\Width: `2`  \n\\n\\n\---\n\\n\`logic [1:0] index;`



            // Multi-dimensional style access

            nested_array[index].inner.addr <= struct_array[addr_val[1:0]].addr;
            ^^^^^^^^^^^^ Ref -> **Variable** `nested_array` in `StructAssignmentTest`  \n\Type: `unpacked array [2] of nested_struct_t`  \n\\n\\n\---\n\\n\`nested_struct_t nested_array[2];`
                         ^^^^^ Ref -> **Variable** `index` in `StructAssignmentTest`  \n\Type: `logic[1:0]`  \n\Width: `2`  \n\\n\\n\---\n\\n\`logic [1:0] index;`
                                ^^^^^ Ref -> **Field** `inner` in `StructAssignmentTest::nested_struct_t`  \n\Type: PackedStruct `simple_struct_t` (`logic[24:0]`)  \n\Width: `25`  \n\\n\\n\---\n\\n\`simple_struct_t inner;`
                                      ^^^^ Ref -> **Field** `addr` in `StructAssignmentTest::simple_struct_t`  \n\Type: `logic[7:0]`  \n\Width: `8`  \n\\n\\n\---\n\\n\`logic [7:0] addr;`
                                              ^^^^^^^^^^^^ Ref -> **Variable** `struct_array` in `StructAssignmentTest`  \n\Type: `unpacked array [4] of simple_struct_t`  \n\\n\\n\---\n\\n\`simple_struct_t struct_array[4];`
                                                           ^^^^^^^^ Ref -> **Variable** `addr_val` in `StructAssignmentTest`  \n\Type: `logic[7:0]`  \n\Width: `8`  \n\\n\\n\---\n\\n\`logic [7:0] addr_val;`
                                                                          ^^^^ Ref -> **Field** `addr` in `StructAssignmentTest::simple_struct_t`  \n\Type: `logic[7:0]`  \n\Width: `8`  \n\\n\\n\---\n\\n\`logic [7:0] addr;`

            nested_array[~index].inner.data <= pkg_array[index + 1].data;
            ^^^^^^^^^^^^ Ref -> **Variable** `nested_array` in `StructAssignmentTest`  \n\Type: `unpacked array [2] of nested_struct_t`  \n\\n\\n\---\n\\n\`nested_struct_t nested_array[2];`
                          ^^^^^ Ref -> **Variable** `index` in `StructAssignmentTest`  \n\Type: `logic[1:0]`  \n\Width: `2`  \n\\n\\n\---\n\\n\`logic [1:0] index;`
                                 ^^^^^ Ref -> **Field** `inner` in `StructAssignmentTest::nested_struct_t`  \n\Type: PackedStruct `simple_struct_t` (`logic[24:0]`)  \n\Width: `25`  \n\\n\\n\---\n\\n\`simple_struct_t inner;`
                                       ^^^^ Ref -> **Field** `data` in `StructAssignmentTest::simple_struct_t`  \n\Type: `logic[15:0]`  \n\Width: `16`  \n\\n\\n\---\n\\n\`logic [15:0] data;`
                                               ^^^^^^^^^ Ref -> **Variable** `pkg_array` in `StructAssignmentTest`  \n\Type: `unpacked array [3] of packet_t`  \n\\n\\n\---\n\\n\`test_pkg::packet_t pkg_array[3];`
                                                         ^^^^^ Ref -> **Variable** `index` in `StructAssignmentTest`  \n\Type: `logic[1:0]`  \n\Width: `2`  \n\\n\\n\---\n\\n\`logic [1:0] index;`
                                                                    ^^^^ Ref -> **Field** `data` in `test_pkg::packet_t`  \n\Type: `logic[15:0]`  \n\Width: `16`  \n\\n\\n\---\n\\n\`logic [15:0] data;`



            // Expression-based assignments

            pkg_struct.id <= {16'h0, addr_val, data_val[7:0]};
            ^^^^^^^^^^ Ref -> **Variable** `pkg_struct` in `StructAssignmentTest`  \n\Type: PackedStruct `packet_t` (`logic[47:0]`)  \n\Width: `48`  \n\\n\\n\---\n\\n\`test_pkg::packet_t pkg_struct;`
                       ^^ Ref -> **Field** `id` in `test_pkg::packet_t`  \n\Type: `id_t` (aka `logic[31:0]`)  \n\Width: `32`  \n\\n\\n\---\n\\n\`id_t id;`
                                     ^^^^^^^^ Ref -> **Variable** `addr_val` in `StructAssignmentTest`  \n\Type: `logic[7:0]`  \n\Width: `8`  \n\\n\\n\---\n\\n\`logic [7:0] addr_val;`
                                               ^^^^^^^^ Ref -> **Variable** `data_val` in `StructAssignmentTest`  \n\Type: `logic[15:0]`  \n\Width: `16`  \n\\n\\n\---\n\\n\`logic [15:0] data_val;`

            pkg_array[index].data <= single_struct.data ^ nested_struct.inner.data;
            ^^^^^^^^^ Ref -> **Variable** `pkg_array` in `StructAssignmentTest`  \n\Type: `unpacked array [3] of packet_t`  \n\\n\\n\---\n\\n\`test_pkg::packet_t pkg_array[3];`
                      ^^^^^ Ref -> **Variable** `index` in `StructAssignmentTest`  \n\Type: `logic[1:0]`  \n\Width: `2`  \n\\n\\n\---\n\\n\`logic [1:0] index;`
                             ^^^^ Ref -> **Field** `data` in `test_pkg::packet_t`  \n\Type: `logic[15:0]`  \n\Width: `16`  \n\\n\\n\---\n\\n\`logic [15:0] data;`
                                     ^^^^^^^^^^^^^ Ref -> **Variable** `single_struct` in `StructAssignmentTest`  \n\Type: PackedStruct `simple_struct_t` (`logic[24:0]`)  \n\Width: `25`  \n\\n\\n\---\n\\n\`// Variables for testing\n\simple_struct_t single_struct;`
                                                   ^^^^ Ref -> **Field** `data` in `StructAssignmentTest::simple_struct_t`  \n\Type: `logic[15:0]`  \n\Width: `16`  \n\\n\\n\---\n\\n\`logic [15:0] data;`
                                                          ^^^^^^^^^^^^^ Ref -> **Variable** `nested_struct` in `StructAssignmentTest`  \n\Type: PackedStruct `nested_struct_t` (`logic[29:0]`)  \n\Width: `30`  \n\\n\\n\---\n\\n\`nested_struct_t nested_struct;`
                                                                        ^^^^^ Ref -> **Field** `inner` in `StructAssignmentTest::nested_struct_t`  \n\Type: PackedStruct `simple_struct_t` (`logic[24:0]`)  \n\Width: `25`  \n\\n\\n\---\n\\n\`simple_struct_t inner;`
                                                                              ^^^^ Ref -> **Field** `data` in `StructAssignmentTest::simple_struct_t`  \n\Type: `logic[15:0]`  \n\Width: `16`  \n\\n\\n\---\n\\n\`logic [15:0] data;`



            // Increment index for next cycle

            index <= index + 1;
            ^^^^^ Ref -> **Variable** `index` in `StructAssignmentTest`  \n\Type: `logic[1:0]`  \n\Width: `2`  \n\\n\\n\---\n\\n\`logic [1:0] index;`
                     ^^^^^ Ref -> **Variable** `index` in `StructAssignmentTest`  \n\Type: `logic[1:0]`  \n\Width: `2`  \n\\n\\n\---\n\\n\`logic [1:0] index;`

            addr_val <= addr_val + 8'h01;
            ^^^^^^^^ Ref -> **Variable** `addr_val` in `StructAssignmentTest`  \n\Type: `logic[7:0]`  \n\Width: `8`  \n\\n\\n\---\n\\n\`logic [7:0] addr_val;`
                        ^^^^^^^^ Ref -> **Variable** `addr_val` in `StructAssignmentTest`  \n\Type: `logic[7:0]`  \n\Width: `8`  \n\\n\\n\---\n\\n\`logic [7:0] addr_val;`

            data_val <= data_val + 16'h0011;
            ^^^^^^^^ Ref -> **Variable** `data_val` in `StructAssignmentTest`  \n\Type: `logic[15:0]`  \n\Width: `16`  \n\\n\\n\---\n\\n\`logic [15:0] data_val;`
                        ^^^^^^^^ Ref -> **Variable** `data_val` in `StructAssignmentTest`  \n\Type: `logic[15:0]`  \n\Width: `16`  \n\\n\\n\---\n\\n\`logic [15:0] data_val;`

        end

    end



    // Combinational assignments

    always_comb begin

        // Direct member assignments in combinational logic

        if (single_struct.valid) begin
            ^^^^^^^^^^^^^ Ref -> **Variable** `single_struct` in `StructAssignmentTest`  \n\Type: PackedStruct `simple_struct_t` (`logic[24:0]`)  \n\Width: `25`  \n\\n\\n\---\n\\n\`// Variables for testing\n\simple_struct_t single_struct;`
                          ^^^^^ Ref -> **Field** `valid` in `StructAssignmentTest::simple_struct_t`  \n\Type: `logic`  \n\\n\\n\---\n\\n\`logic valid;`

            nested_struct.tag = struct_array[0].addr[3:0];
            ^^^^^^^^^^^^^ Ref -> **Variable** `nested_struct` in `StructAssignmentTest`  \n\Type: PackedStruct `nested_struct_t` (`logic[29:0]`)  \n\Width: `30`  \n\\n\\n\---\n\\n\`nested_struct_t nested_struct;`
                          ^^^ Ref -> **Field** `tag` in `StructAssignmentTest::nested_struct_t`  \n\Type: `logic[3:0]`  \n\Width: `4`  \n\\n\\n\---\n\\n\`logic [3:0] tag;`
                                ^^^^^^^^^^^^ Ref -> **Variable** `struct_array` in `StructAssignmentTest`  \n\Type: `unpacked array [4] of simple_struct_t`  \n\\n\\n\---\n\\n\`simple_struct_t struct_array[4];`

            nested_struct.enable = |pkg_struct.id;
            ^^^^^^^^^^^^^ Ref -> **Variable** `nested_struct` in `StructAssignmentTest`  \n\Type: PackedStruct `nested_struct_t` (`logic[29:0]`)  \n\Width: `30`  \n\\n\\n\---\n\\n\`nested_struct_t nested_struct;`
                          ^^^^^^ Ref -> **Field** `enable` in `StructAssignmentTest::nested_struct_t`  \n\Type: `logic`  \n\\n\\n\---\n\\n\`logic enable;`
                                    ^^^^^^^^^^ Ref -> **Variable** `pkg_struct` in `StructAssignmentTest`  \n\Type: PackedStruct `packet_t` (`logic[47:0]`)  \n\Width: `48`  \n\\n\\n\---\n\\n\`test_pkg::packet_t pkg_struct;`
                                               ^^ Ref -> **Field** `id` in `test_pkg::packet_t`  \n\Type: `id_t` (aka `logic[31:0]`)  \n\Width: `32`  \n\\n\\n\---\n\\n\`id_t id;`

        end else begin

            nested_struct.tag = 4'h0;
            ^^^^^^^^^^^^^ Ref -> **Variable** `nested_struct` in `StructAssignmentTest`  \n\Type: PackedStruct `nested_struct_t` (`logic[29:0]`)  \n\Width: `30`  \n\\n\\n\---\n\\n\`nested_struct_t nested_struct;`
                          ^^^ Ref -> **Field** `tag` in `StructAssignmentTest::nested_struct_t`  \n\Type: `logic[3:0]`  \n\Width: `4`  \n\\n\\n\---\n\\n\`logic [3:0] tag;`

            nested_struct.enable = 1'b0;
            ^^^^^^^^^^^^^ Ref -> **Variable** `nested_struct` in `StructAssignmentTest`  \n\Type: PackedStruct `nested_struct_t` (`logic[29:0]`)  \n\Width: `30`  \n\\n\\n\---\n\\n\`nested_struct_t nested_struct;`
                          ^^^^^^ Ref -> **Field** `enable` in `StructAssignmentTest::nested_struct_t`  \n\Type: `logic`  \n\\n\\n\---\n\\n\`logic enable;`

        end

    end



    // Initial block assignments

    initial begin

        single_struct.addr = 8'h77;
        ^^^^^^^^^^^^^ Ref -> **Variable** `single_struct` in `StructAssignmentTest`  \n\Type: PackedStruct `simple_struct_t` (`logic[24:0]`)  \n\Width: `25`  \n\\n\\n\---\n\\n\`// Variables for testing\n\simple_struct_t single_struct;`
                      ^^^^ Ref -> **Field** `addr` in `StructAssignmentTest::simple_struct_t`  \n\Type: `logic[7:0]`  \n\Width: `8`  \n\\n\\n\---\n\\n\`logic [7:0] addr;`

        single_struct.data = 16'h8888;
        ^^^^^^^^^^^^^ Ref -> **Variable** `single_struct` in `StructAssignmentTest`  \n\Type: PackedStruct `simple_struct_t` (`logic[24:0]`)  \n\Width: `25`  \n\\n\\n\---\n\\n\`// Variables for testing\n\simple_struct_t single_struct;`
                      ^^^^ Ref -> **Field** `data` in `StructAssignmentTest::simple_struct_t`  \n\Type: `logic[15:0]`  \n\Width: `16`  \n\\n\\n\---\n\\n\`logic [15:0] data;`

        single_struct.valid = 1'b1;
        ^^^^^^^^^^^^^ Ref -> **Variable** `single_struct` in `StructAssignmentTest`  \n\Type: PackedStruct `simple_struct_t` (`logic[24:0]`)  \n\Width: `25`  \n\\n\\n\---\n\\n\`// Variables for testing\n\simple_struct_t single_struct;`
                      ^^^^^ Ref -> **Field** `valid` in `StructAssignmentTest::simple_struct_t`  \n\Type: `logic`  \n\\n\\n\---\n\\n\`logic valid;`



        struct_array[3].addr = 8'h99;
        ^^^^^^^^^^^^ Ref -> **Variable** `struct_array` in `StructAssignmentTest`  \n\Type: `unpacked array [4] of simple_struct_t`  \n\\n\\n\---\n\\n\`simple_struct_t struct_array[4];`
                        ^^^^ Ref -> **Field** `addr` in `StructAssignmentTest::simple_struct_t`  \n\Type: `logic[7:0]`  \n\Width: `8`  \n\\n\\n\---\n\\n\`logic [7:0] addr;`

        struct_array[3].data = 16'hAAAA;
        ^^^^^^^^^^^^ Ref -> **Variable** `struct_array` in `StructAssignmentTest`  \n\Type: `unpacked array [4] of simple_struct_t`  \n\\n\\n\---\n\\n\`simple_struct_t struct_array[4];`
                        ^^^^ Ref -> **Field** `data` in `StructAssignmentTest::simple_struct_t`  \n\Type: `logic[15:0]`  \n\Width: `16`  \n\\n\\n\---\n\\n\`logic [15:0] data;`

        struct_array[3].valid = 1'b0;
        ^^^^^^^^^^^^ Ref -> **Variable** `struct_array` in `StructAssignmentTest`  \n\Type: `unpacked array [4] of simple_struct_t`  \n\\n\\n\---\n\\n\`simple_struct_t struct_array[4];`
                        ^^^^^ Ref -> **Field** `valid` in `StructAssignmentTest::simple_struct_t`  \n\Type: `logic`  \n\\n\\n\---\n\\n\`logic valid;`



        nested_array[1].inner.addr = 8'hBB;
        ^^^^^^^^^^^^ Ref -> **Variable** `nested_array` in `StructAssignmentTest`  \n\Type: `unpacked array [2] of nested_struct_t`  \n\\n\\n\---\n\\n\`nested_struct_t nested_array[2];`
                        ^^^^^ Ref -> **Field** `inner` in `StructAssignmentTest::nested_struct_t`  \n\Type: PackedStruct `simple_struct_t` (`logic[24:0]`)  \n\Width: `25`  \n\\n\\n\---\n\\n\`simple_struct_t inner;`
                              ^^^^ Ref -> **Field** `addr` in `StructAssignmentTest::simple_struct_t`  \n\Type: `logic[7:0]`  \n\Width: `8`  \n\\n\\n\---\n\\n\`logic [7:0] addr;`

        nested_array[1].inner.data = 16'hCCCC;
        ^^^^^^^^^^^^ Ref -> **Variable** `nested_array` in `StructAssignmentTest`  \n\Type: `unpacked array [2] of nested_struct_t`  \n\\n\\n\---\n\\n\`nested_struct_t nested_array[2];`
                        ^^^^^ Ref -> **Field** `inner` in `StructAssignmentTest::nested_struct_t`  \n\Type: PackedStruct `simple_struct_t` (`logic[24:0]`)  \n\Width: `25`  \n\\n\\n\---\n\\n\`simple_struct_t inner;`
                              ^^^^ Ref -> **Field** `data` in `StructAssignmentTest::simple_struct_t`  \n\Type: `logic[15:0]`  \n\Width: `16`  \n\\n\\n\---\n\\n\`logic [15:0] data;`

        nested_array[1].tag = 4'hD;
        ^^^^^^^^^^^^ Ref -> **Variable** `nested_array` in `StructAssignmentTest`  \n\Type: `unpacked array [2] of nested_struct_t`  \n\\n\\n\---\n\\n\`nested_struct_t nested_array[2];`
                        ^^^ Ref -> **Field** `tag` in `StructAssignmentTest::nested_struct_t`  \n\Type: `logic[3:0]`  \n\Width: `4`  \n\\n\\n\---\n\\n\`logic [3:0] tag;`



        pkg_array[2].id = 32'hDEAD;
        ^^^^^^^^^ Ref -> **Variable** `pkg_array` in `StructAssignmentTest`  \n\Type: `unpacked array [3] of packet_t`  \n\\n\\n\---\n\\n\`test_pkg::packet_t pkg_array[3];`
                     ^^ Ref -> **Field** `id` in `test_pkg::packet_t`  \n\Type: `id_t` (aka `logic[31:0]`)  \n\Width: `32`  \n\\n\\n\---\n\\n\`id_t id;`

        pkg_array[2].data = 16'hBEEF;
        ^^^^^^^^^ Ref -> **Variable** `pkg_array` in `StructAssignmentTest`  \n\Type: `unpacked array [3] of packet_t`  \n\\n\\n\---\n\\n\`test_pkg::packet_t pkg_array[3];`
                     ^^^^ Ref -> **Field** `data` in `test_pkg::packet_t`  \n\Type: `logic[15:0]`  \n\Width: `16`  \n\\n\\n\---\n\\n\`logic [15:0] data;`

    end



endmodule
