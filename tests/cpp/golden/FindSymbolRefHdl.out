
package test_pkg;
        ^^^^^^^^ Sym test_pkg : PackageDeclaration

    parameter int WIDTH = 32;
                  ^^^^^ Sym WIDTH : Declarator

    typedef logic [WIDTH-1:0] id_t;
                   ^^^^^ Ref -> `parameter int WIDTH = 32`
                              ^^^^ Sym id_t : TypedefDeclaration



    typedef struct packed {

        id_t id;
        ^^^^ Ref -> `typedef logic [WIDTH-1:0] id_t;`

        logic [15:0] data;

    } packet_t;
      ^^^^^^^^ Sym packet_t : TypedefDeclaration



    typedef enum logic [1:0] {

        STATE_A,

        STATE_B,

        STATE_C

    } state_t;
      ^^^^^^^ Sym state_t : TypedefDeclaration



    parameter type data_t = logic [7:0];
                   ^^^^^^ Sym data_t : TypeAssignment

endpackage



interface bus_if #(
          ^^^^^^ Sym bus_if : InterfaceDeclaration

    parameter type data_t = bit,
                   ^^^^^^ Sym data_t : TypeAssignment

    parameter int ADDR_WIDTH = 32
                  ^^^^^^^^^^ Sym ADDR_WIDTH : Declarator

)(

    input logic clk,
                ^^^ Sym clk : Declarator

    input logic rst
                ^^^ Sym rst : Declarator

);



    logic valid;
          ^^^^^ Sym valid : Declarator

    logic ready;
          ^^^^^ Sym ready : Declarator

    logic [ADDR_WIDTH-1:0] addr;
           ^^^^^^^^^^ Ref -> `parameter int ADDR_WIDTH = 32`
                           ^^^^ Sym addr : Declarator

    data_t data;
    ^^^^^^ Ref -> `data_t = bit`
           ^^^^ Sym data : Declarator

    logic write_enable;
          ^^^^^^^^^^^^ Sym write_enable : Declarator



    // Modport for master

    modport master (
            ^^^^^^ Sym master : ModportDeclaration

        input clk, rst, ready,
              ^^^ Sym clk : ModportSimplePortList
                   ^^^ Sym rst : ModportSimplePortList
                        ^^^^^ Sym ready : ModportSimplePortList

        output valid, addr, data, write_enable
               ^^^^^ Sym valid : ModportSimplePortList
                      ^^^^ Sym addr : ModportSimplePortList
                            ^^^^ Sym data : ModportSimplePortList
                                  ^^^^^^^^^^^^ Sym write_enable : ModportSimplePortList

    );



    // Modport for follower

    modport follower (
            ^^^^^^^^ Sym follower : ModportDeclaration

        input clk, rst, valid, addr, data, write_enable,
              ^^^ Sym clk : ModportSimplePortList
                   ^^^ Sym rst : ModportSimplePortList
                        ^^^^^ Sym valid : ModportSimplePortList
                               ^^^^ Sym addr : ModportSimplePortList
                                     ^^^^ Sym data : ModportSimplePortList
                                           ^^^^^^^^^^^^ Sym write_enable : ModportSimplePortList

        output ready
               ^^^^^ Sym ready : ModportSimplePortList

    );



    // Task for master to write data

    task automatic write_data(input logic [ADDR_WIDTH-1:0] address, input data_t write_data);
                   ^^^^^^^^^^ Sym write_data : TaskDeclaration
                                           ^^^^^^^^^^ Ref -> `// In bus_if`\n\\n\---\n\\n\`parameter int ADDR_WIDTH = 32`
                                                           ^^^^^^^ Sym address : Declarator
                                                                          ^^^^^^ Ref -> `// In bus_if`\n\\n\---\n\\n\`data_t = bit`
                                                                                 ^^^^^^^^^^ Sym write_data : Declarator

        @(posedge clk);
                  ^^^ Ref -> `// In bus_if`\n\\n\---\n\\n\`input logic clk`

        addr <= address;
        ^^^^ Ref -> `// In bus_if`\n\\n\---\n\\n\`logic [ADDR_WIDTH-1:0] addr;`
                ^^^^^^^ Ref -> `input logic [ADDR_WIDTH-1:0] address`

        data <= write_data;
        ^^^^ Ref -> `// In bus_if`\n\\n\---\n\\n\`data_t data;`
                ^^^^^^^^^^ Ref -> `input data_t write_data`

        write_enable <= 1'b1;
        ^^^^^^^^^^^^ Ref -> `// In bus_if`\n\\n\---\n\\n\`logic write_enable;`

        valid <= 1'b1;
        ^^^^^ Ref -> `// In bus_if`\n\\n\---\n\\n\`logic valid;`

        @(posedge clk iff ready);
                  ^^^ Ref -> `// In bus_if`\n\\n\---\n\\n\`input logic clk`
                          ^^^^^ Ref -> `// In bus_if`\n\\n\---\n\\n\`logic ready;`

        valid <= 1'b0;
        ^^^^^ Ref -> `// In bus_if`\n\\n\---\n\\n\`logic valid;`

        write_enable <= 1'b0;
        ^^^^^^^^^^^^ Ref -> `// In bus_if`\n\\n\---\n\\n\`logic write_enable;`

    endtask



    // Task for master to read data

    task automatic read_data(input logic [ADDR_WIDTH-1:0] address, output data_t read_data);
                   ^^^^^^^^^ Sym read_data : TaskDeclaration
                                          ^^^^^^^^^^ Ref -> `// In bus_if`\n\\n\---\n\\n\`parameter int ADDR_WIDTH = 32`
                                                          ^^^^^^^ Sym address : Declarator
                                                                          ^^^^^^ Ref -> `// In bus_if`\n\\n\---\n\\n\`data_t = bit`
                                                                                 ^^^^^^^^^ Sym read_data : Declarator

        @(posedge clk);
                  ^^^ Ref -> `// In bus_if`\n\\n\---\n\\n\`input logic clk`

        addr <= address;
        ^^^^ Ref -> `// In bus_if`\n\\n\---\n\\n\`logic [ADDR_WIDTH-1:0] addr;`
                ^^^^^^^ Ref -> `input logic [ADDR_WIDTH-1:0] address`

        write_enable <= 1'b0;
        ^^^^^^^^^^^^ Ref -> `// In bus_if`\n\\n\---\n\\n\`logic write_enable;`

        valid <= 1'b1;
        ^^^^^ Ref -> `// In bus_if`\n\\n\---\n\\n\`logic valid;`

        @(posedge clk iff ready);
                  ^^^ Ref -> `// In bus_if`\n\\n\---\n\\n\`input logic clk`
                          ^^^^^ Ref -> `// In bus_if`\n\\n\---\n\\n\`logic ready;`

        read_data = data;
        ^^^^^^^^^ Ref -> `output data_t read_data`
                    ^^^^ Ref -> `// In bus_if`\n\\n\---\n\\n\`data_t data;`

        valid <= 1'b0;
        ^^^^^ Ref -> `// In bus_if`\n\\n\---\n\\n\`logic valid;`

    endtask



endinterface



module Sub #(
       ^^^ Sym Sub : ModuleDeclaration

    parameter int WIDTH = 16
                  ^^^^^ Sym WIDTH : Declarator

)(

    input logic clk,
                ^^^ Sym clk : Declarator

    input logic rst,
                ^^^ Sym rst : Declarator

    input logic [WIDTH-1:0] data_in,
                 ^^^^^ Ref -> `parameter int WIDTH = 16`
                            ^^^^^^^ Sym data_in : Declarator

    output logic [WIDTH-1:0] data_out
                  ^^^^^ Ref -> `parameter int WIDTH = 16`
                             ^^^^^^^^ Sym data_out : Declarator

);



    always_ff @(posedge clk or posedge rst) begin
                        ^^^ Ref -> `input logic clk`
                                       ^^^ Ref -> `input logic rst`

        if (rst) begin
            ^^^ Ref -> `input logic rst`

            data_out <= '0;
            ^^^^^^^^ Ref -> `output logic [WIDTH-1:0] data_out`

        end else begin

            data_out <= data_in;
            ^^^^^^^^ Ref -> `output logic [WIDTH-1:0] data_out`
                        ^^^^^^^ Ref -> `input logic [WIDTH-1:0] data_in`

        end

    end



endmodule



module TestModule (
       ^^^^^^^^^^ Sym TestModule : ModuleDeclaration

    input logic clk,
                ^^^ Sym clk : Declarator

    input logic rst,
                ^^^ Sym rst : Declarator

    // some useful info

    input logic          [test_pkg::WIDTH-1:0] width_port,
                          ^^^^^^^^ Ref -> `package test_pkg;`
                                    ^^^^^ Ref -> `// In test_pkg`\n\\n\---\n\\n\`parameter int WIDTH = 32`
                                               ^^^^^^^^^^ Sym width_port : Declarator

    input test_pkg::id_t [test_pkg::WIDTH-1:0] id_array,
          ^^^^^^^^ Ref -> `package test_pkg;`
                    ^^^^ Ref -> `// In test_pkg`\n\\n\---\n\\n\`typedef logic [WIDTH-1:0] id_t;`
                          ^^^^^^^^ Ref -> `package test_pkg;`
                                    ^^^^^ Ref -> `// In test_pkg`\n\\n\---\n\\n\`parameter int WIDTH = 32`
                                               ^^^^^^^^ Sym id_array : Declarator

    input test_pkg::packet_t pkt_in,
          ^^^^^^^^ Ref -> `package test_pkg;`
                    ^^^^^^^^ Ref -> `// In test_pkg`\n\\n\---\n\\n\`typedef struct packed {\n\    id_t id;\n\    logic [15:0] data;\n\} packet_t;`
                             ^^^^^^ Sym pkt_in : Declarator

    output test_pkg::data_t data_out,
           ^^^^^^^^ Ref -> `package test_pkg;`
                     ^^^^^^ Ref -> `// In test_pkg`\n\\n\---\n\\n\`data_t = logic [7:0]`
                            ^^^^^^^^ Sym data_out : Declarator

    bus_if.master bus_master,
    ^^^^^^ Ref -> `interface bus_if #(\n\    parameter type data_t = bit,\n\    parameter int ADDR_WIDTH = 32\n\)(\n\    input logic clk,\n\    input logic rst\n\);`
           ^ Ref -> `// In bus_if`\n\\n\---\n\\n\`// Modport for master\n\modport master (\n\    input clk, rst, ready,\n\    output valid, addr, data, write_enable\n\);`
            ^ Ref -> `// In bus_if`\n\\n\---\n\\n\`// Modport for master\n\modport master (\n\    input clk, rst, ready,\n\    output valid, addr, data, write_enable\n\);`
             ^ Ref -> `// In bus_if`\n\\n\---\n\\n\`// Modport for master\n\modport master (\n\    input clk, rst, ready,\n\    output valid, addr, data, write_enable\n\);`
              ^ Ref -> `// In bus_if`\n\\n\---\n\\n\`// Modport for master\n\modport master (\n\    input clk, rst, ready,\n\    output valid, addr, data, write_enable\n\);`
               ^ Ref -> `// In bus_if`\n\\n\---\n\\n\`// Modport for master\n\modport master (\n\    input clk, rst, ready,\n\    output valid, addr, data, write_enable\n\);`
                ^ Ref -> `// In bus_if`\n\\n\---\n\\n\`// Modport for master\n\modport master (\n\    input clk, rst, ready,\n\    output valid, addr, data, write_enable\n\);`
                  ^^^^^^^^^^ Sym bus_master : Declarator

    bus_if.follower bus_follower
    ^^^^^^ Ref -> `interface bus_if #(\n\    parameter type data_t = bit,\n\    parameter int ADDR_WIDTH = 32\n\)(\n\    input logic clk,\n\    input logic rst\n\);`
           ^ Ref -> `// In bus_if`\n\\n\---\n\\n\`// Modport for follower\n\modport follower (\n\    input clk, rst, valid, addr, data, write_enable,\n\    output ready\n\);`
            ^ Ref -> `// In bus_if`\n\\n\---\n\\n\`// Modport for follower\n\modport follower (\n\    input clk, rst, valid, addr, data, write_enable,\n\    output ready\n\);`
             ^ Ref -> `// In bus_if`\n\\n\---\n\\n\`// Modport for follower\n\modport follower (\n\    input clk, rst, valid, addr, data, write_enable,\n\    output ready\n\);`
              ^ Ref -> `// In bus_if`\n\\n\---\n\\n\`// Modport for follower\n\modport follower (\n\    input clk, rst, valid, addr, data, write_enable,\n\    output ready\n\);`
               ^ Ref -> `// In bus_if`\n\\n\---\n\\n\`// Modport for follower\n\modport follower (\n\    input clk, rst, valid, addr, data, write_enable,\n\    output ready\n\);`
                ^ Ref -> `// In bus_if`\n\\n\---\n\\n\`// Modport for follower\n\modport follower (\n\    input clk, rst, valid, addr, data, write_enable,\n\    output ready\n\);`
                 ^ Ref -> `// In bus_if`\n\\n\---\n\\n\`// Modport for follower\n\modport follower (\n\    input clk, rst, valid, addr, data, write_enable,\n\    output ready\n\);`
                  ^ Ref -> `// In bus_if`\n\\n\---\n\\n\`// Modport for follower\n\modport follower (\n\    input clk, rst, valid, addr, data, write_enable,\n\    output ready\n\);`
                    ^^^^^^^^^^^^ Sym bus_follower : Declarator

);



    test_pkg::state_t state, state_next;
    ^^^^^^^^ Ref -> `package test_pkg;`
              ^^^^^^^ Ref -> `// In test_pkg`\n\\n\---\n\\n\`typedef enum logic [1:0] {\n\    STATE_A,\n\    STATE_B,\n\    STATE_C\n\} state_t;`
                      ^^^^^ Sym state : Declarator
                             ^^^^^^^^^^ Sym state_next : Declarator

    test_pkg::id_t counter;
    ^^^^^^^^ Ref -> `package test_pkg;`
              ^^^^ Ref -> `// In test_pkg`\n\\n\---\n\\n\`typedef logic [WIDTH-1:0] id_t;`
                   ^^^^^^^ Sym counter : Declarator



    always_ff @(posedge clk) begin
                        ^^^ Ref -> `input logic clk`

        if (rst) begin
            ^^^ Ref -> `input logic rst`

            state <= test_pkg::STATE_A;
            ^^^^^ Ref -> `test_pkg::state_t state, state_next;`
                     ^^^^^^^^ Ref -> `package test_pkg;`
                               ^^^^^^^ Ref -> `// In test_pkg::state_t`\n\\n\---\n\\n\`typedef enum logic [1:0] {\n\    STATE_A,\n\    STATE_B,\n\    STATE_C\n\} state_t;`

            counter <= '0;
            ^^^^^^^ Ref -> `test_pkg::id_t counter;`

        end else begin

            state <= state_next;
            ^^^^^ Ref -> `test_pkg::state_t state, state_next;`
                     ^^^^^^^^^^ Ref -> `test_pkg::state_t state, state_next;`

            counter <= counter + 1'b1;
            ^^^^^^^ Ref -> `test_pkg::id_t counter;`
                       ^^^^^^^ Ref -> `test_pkg::id_t counter;`

        end

    end



    always_comb begin

        case (state)
              ^^^^^ Ref -> `test_pkg::state_t state, state_next;`

            test_pkg::STATE_A: state_next = test_pkg::STATE_B;
            ^^^^^^^^ Ref -> `package test_pkg;`
                      ^^^^^^^ Ref -> `// In test_pkg::state_t`\n\\n\---\n\\n\`typedef enum logic [1:0] {\n\    STATE_A,\n\    STATE_B,\n\    STATE_C\n\} state_t;`
                               ^^^^^^^^^^ Ref -> `test_pkg::state_t state, state_next;`
                                            ^^^^^^^^ Ref -> `package test_pkg;`
                                                      ^^^^^^^ Ref -> `// In test_pkg::state_t`\n\\n\---\n\\n\`typedef enum logic [1:0] {\n\    STATE_A,\n\    STATE_B,\n\    STATE_C\n\} state_t;`

            test_pkg::STATE_B: state_next = test_pkg::STATE_C;
            ^^^^^^^^ Ref -> `package test_pkg;`
                      ^^^^^^^ Ref -> `// In test_pkg::state_t`\n\\n\---\n\\n\`typedef enum logic [1:0] {\n\    STATE_A,\n\    STATE_B,\n\    STATE_C\n\} state_t;`
                               ^^^^^^^^^^ Ref -> `test_pkg::state_t state, state_next;`
                                            ^^^^^^^^ Ref -> `package test_pkg;`
                                                      ^^^^^^^ Ref -> `// In test_pkg::state_t`\n\\n\---\n\\n\`typedef enum logic [1:0] {\n\    STATE_A,\n\    STATE_B,\n\    STATE_C\n\} state_t;`

            default: state_next = test_pkg::STATE_A;
                     ^^^^^^^^^^ Ref -> `test_pkg::state_t state, state_next;`
                                  ^^^^^^^^ Ref -> `package test_pkg;`
                                            ^^^^^^^ Ref -> `// In test_pkg::state_t`\n\\n\---\n\\n\`typedef enum logic [1:0] {\n\    STATE_A,\n\    STATE_B,\n\    STATE_C\n\} state_t;`

        endcase

    end



    // Use the bus interfaces

    always_ff @(posedge clk) begin
                        ^^^ Ref -> `input logic clk`

        if (rst) begin
            ^^^ Ref -> `input logic rst`

            data_out <= '0;
            ^^^^^^^^ Ref -> `output test_pkg::data_t data_out`

            bus_follower.ready <= 1'b0;
            ^^^^^^^^^^^^ Ref -> `bus_if.follower bus_follower`
                         ^^^^^ Ref -> `// In bus_if.follower`\n\\n\---\n\\n\`output ready`

        end else begin

            // Simple follower logic - always ready, echo data

            bus_follower.ready <= 1'b1;
            ^^^^^^^^^^^^ Ref -> `bus_if.follower bus_follower`
                         ^^^^^ Ref -> `// In bus_if.follower`\n\\n\---\n\\n\`output ready`

            if (bus_follower.valid && bus_follower.write_enable) begin
                ^^^^^^^^^^^^ Ref -> `bus_if.follower bus_follower`
                             ^^^^^ Ref -> `// In bus_if.follower`\n\\n\---\n\\n\`input clk, rst, valid, addr, data, write_enable`
                                      ^^^^^^^^^^^^ Ref -> `bus_if.follower bus_follower`
                                                   ^^^^^^^^^^^^ Ref -> `// In bus_if.follower`\n\\n\---\n\\n\`input clk, rst, valid, addr, data, write_enable`

                data_out <= bus_follower.data[7:0]; // Convert to data_t size
                ^^^^^^^^ Ref -> `output test_pkg::data_t data_out`
                            ^^^^^^^^^^^^ Ref -> `bus_if.follower bus_follower`
                                         ^^^^ Ref -> `// In bus_if.follower`\n\\n\---\n\\n\`input clk, rst, valid, addr, data, write_enable`

            end

        end

    end



    // Master interface usage example

    initial begin

        bus_master.valid <= 1'b0;
        ^^^^^^^^^^ Ref -> `bus_if.master bus_master`
                   ^^^^^ Ref -> `// In bus_if.master`\n\\n\---\n\\n\`output valid, addr, data, write_enable`

        bus_master.write_enable <= 1'b0;
        ^^^^^^^^^^ Ref -> `bus_if.master bus_master`
                   ^^^^^^^^^^^^ Ref -> `// In bus_if.master`\n\\n\---\n\\n\`output valid, addr, data, write_enable`

        bus_master.addr = width_port[0];
        ^^^^^^^^^^ Ref -> `bus_if.master bus_master`
                   ^^^^ Ref -> `// In bus_if.master`\n\\n\---\n\\n\`output valid, addr, data, write_enable`
                          ^^^^^^^^^^ Ref -> `// some useful info\n\input logic          [test_pkg::WIDTH-1:0] width_port`

        bus_master.data <= state;
        ^^^^^^^^^^ Ref -> `bus_if.master bus_master`
                   ^^^^ Ref -> `// In bus_if.master`\n\\n\---\n\\n\`output valid, addr, data, write_enable`
                           ^^^^^ Ref -> `test_pkg::state_t state, state_next;`



    end



endmodule





module NoDefaults #(
       ^^^^^^^^^^ Sym NoDefaults : ModuleDeclaration

    parameter int WIDTH,
                  ^^^^^ Sym WIDTH : Declarator

    parameter int n_iters,
                  ^^^^^^^ Sym n_iters : Declarator

    parameter bit gen_branch = 0
                  ^^^^^^^^^^ Sym gen_branch : Declarator

)(

    input logic clk,
                ^^^ Sym clk : Declarator

    input logic rst,
                ^^^ Sym rst : Declarator

    input logic [WIDTH-1:0] data_in,
                 ^^^^^ Ref -> `parameter int WIDTH`
                            ^^^^^^^ Sym data_in : Declarator

    output logic [WIDTH-1:0] data_out
                  ^^^^^ Ref -> `parameter int WIDTH`
                             ^^^^^^^^ Sym data_out : Declarator

);



    Sub #(
    ^^^ Ref -> `module Sub #(\n\    parameter int WIDTH = 16\n\)(\n\    input logic clk,\n\    input logic rst,\n\    input logic [WIDTH-1:0] data_in,\n\    output logic [WIDTH-1:0] data_out\n\);`

        .WIDTH(WIDTH)
         ^^^^^ Ref -> `// In Sub`\n\\n\---\n\\n\`parameter int WIDTH = 16`
               ^^^^^ Ref -> `parameter int WIDTH`

    ) sub_inst (
      ^^^^^^^^ Sym sub_inst : HierarchicalInstance

        .clk(clk),
         ^^^ Ref -> `// In Sub`\n\\n\---\n\\n\`input logic clk`
             ^^^ Ref -> `input logic clk`

        .rst(rst),
         ^^^ Ref -> `// In Sub`\n\\n\---\n\\n\`input logic rst`
             ^^^ Ref -> `input logic rst`

        .data_in(data_in),
         ^^^^^^^ Ref -> `// In Sub`\n\\n\---\n\\n\`input logic [WIDTH-1:0] data_in`
                 ^^^^^^^ Ref -> `input logic [WIDTH-1:0] data_in`

        .data_out(data_out)
         ^^^^^^^^ Ref -> `// In Sub`\n\\n\---\n\\n\`output logic [WIDTH-1:0] data_out`
                  ^^^^^^^^ Ref -> `output logic [WIDTH-1:0] data_out`

    );



    genvar i;
           ^ Sym i : IdentifierName

    for(i = 0; i < n_iters; i++) begin : gen_loop
               ^ Ref -> `// In NoDefaults`\n\\n\---\n\\n\`i`
                   ^^^^^^^ Ref -> `// In NoDefaults`\n\\n\---\n\\n\`parameter int n_iters`
                            ^ Ref -> `// In NoDefaults`\n\\n\---\n\\n\`i`
                                         ^^^^^^^^ Sym gen_loop : LoopGenerate

        Sub #(
        ^^^ Ref -> `module Sub #(\n\    parameter int WIDTH = 16\n\)(\n\    input logic clk,\n\    input logic rst,\n\    input logic [WIDTH-1:0] data_in,\n\    output logic [WIDTH-1:0] data_out\n\);`

            .WIDTH(WIDTH)
             ^^^^^ Ref -> `// In Sub`\n\\n\---\n\\n\`parameter int WIDTH = 16`
                   ^^^^^ Ref -> `// In NoDefaults`\n\\n\---\n\\n\`parameter int WIDTH`

         ) sub (
           ^^^ Sym sub : HierarchicalInstance

            .clk(clk),
             ^^^ Ref -> `// In Sub`\n\\n\---\n\\n\`input logic clk`
                 ^^^ Ref -> `// In NoDefaults`\n\\n\---\n\\n\`input logic clk`

            .rst(rst),
             ^^^ Ref -> `// In Sub`\n\\n\---\n\\n\`input logic rst`
                 ^^^ Ref -> `// In NoDefaults`\n\\n\---\n\\n\`input logic rst`

            .data_in(data_in),
             ^^^^^^^ Ref -> `// In Sub`\n\\n\---\n\\n\`input logic [WIDTH-1:0] data_in`
                     ^^^^^^^ Ref -> `// In NoDefaults`\n\\n\---\n\\n\`input logic [WIDTH-1:0] data_in`

            .data_out(data_out)
             ^^^^^^^^ Ref -> `// In Sub`\n\\n\---\n\\n\`output logic [WIDTH-1:0] data_out`
                      ^^^^^^^^ Ref -> `// In NoDefaults`\n\\n\---\n\\n\`output logic [WIDTH-1:0] data_out`

        );

    end



    if (gen_branch) begin : gen_branch_block
        ^^^^^^^^^^ Ref -> `parameter bit gen_branch = 0`
                            ^^^^^^^^^^^^^^^^ Sym gen_branch_block : GenerateBlock

        Sub #(
        ^^^ Ref -> `module Sub #(\n\    parameter int WIDTH = 16\n\)(\n\    input logic clk,\n\    input logic rst,\n\    input logic [WIDTH-1:0] data_in,\n\    output logic [WIDTH-1:0] data_out\n\);`

            .WIDTH(WIDTH)
             ^^^^^ Ref -> `// In Sub`\n\\n\---\n\\n\`parameter int WIDTH = 16`
                   ^^^^^ Ref -> `// In NoDefaults`\n\\n\---\n\\n\`parameter int WIDTH`

        ) sub_branch (
          ^^^^^^^^^^ Sym sub_branch : HierarchicalInstance

            .clk(clk),
             ^^^ Ref -> `// In Sub`\n\\n\---\n\\n\`input logic clk`
                 ^^^ Ref -> `// In NoDefaults`\n\\n\---\n\\n\`input logic clk`

            .rst(rst),
             ^^^ Ref -> `// In Sub`\n\\n\---\n\\n\`input logic rst`
                 ^^^ Ref -> `// In NoDefaults`\n\\n\---\n\\n\`input logic rst`

            .data_in(data_in),
             ^^^^^^^ Ref -> `// In Sub`\n\\n\---\n\\n\`input logic [WIDTH-1:0] data_in`
                     ^^^^^^^ Ref -> `// In NoDefaults`\n\\n\---\n\\n\`input logic [WIDTH-1:0] data_in`

            .data_out(data_out)
             ^^^^^^^^ Ref -> `// In Sub`\n\\n\---\n\\n\`output logic [WIDTH-1:0] data_out`
                      ^^^^^^^^ Ref -> `// In NoDefaults`\n\\n\---\n\\n\`output logic [WIDTH-1:0] data_out`

        );

    end else begin : gen_no_branch_block
                     ^^^^^^^^^^^^^^^^^^^ Sym gen_no_branch_block : GenerateBlock

        Sub #(
        ^^^ Ref -> `module Sub #(\n\    parameter int WIDTH = 16\n\)(\n\    input logic clk,\n\    input logic rst,\n\    input logic [WIDTH-1:0] data_in,\n\    output logic [WIDTH-1:0] data_out\n\);`

            .WIDTH(WIDTH)
             ^^^^^ Ref -> `// In Sub`\n\\n\---\n\\n\`parameter int WIDTH = 16`
                   ^^^^^ Ref -> `// In NoDefaults`\n\\n\---\n\\n\`parameter int WIDTH`

        ) sub_no_branch (
          ^^^^^^^^^^^^^ Sym sub_no_branch : HierarchicalInstance

            .clk(clk),
             ^^^ Ref -> `// In Sub`\n\\n\---\n\\n\`input logic clk`
                 ^^^ Ref -> `// In NoDefaults`\n\\n\---\n\\n\`input logic clk`

            .rst(rst),
             ^^^ Ref -> `// In Sub`\n\\n\---\n\\n\`input logic rst`
                 ^^^ Ref -> `// In NoDefaults`\n\\n\---\n\\n\`input logic rst`

            .data_in(data_in),
             ^^^^^^^ Ref -> `// In Sub`\n\\n\---\n\\n\`input logic [WIDTH-1:0] data_in`
                     ^^^^^^^ Ref -> `// In NoDefaults`\n\\n\---\n\\n\`input logic [WIDTH-1:0] data_in`

            .data_out(data_out)
             ^^^^^^^^ Ref -> `// In Sub`\n\\n\---\n\\n\`output logic [WIDTH-1:0] data_out`
                      ^^^^^^^^ Ref -> `// In NoDefaults`\n\\n\---\n\\n\`output logic [WIDTH-1:0] data_out`

        );

    end



endmodule



module StructAssignmentTest (
       ^^^^^^^^^^^^^^^^^^^^ Sym StructAssignmentTest : ModuleDeclaration

    input logic clk,
                ^^^ Sym clk : Declarator

    input logic rst
                ^^^ Sym rst : Declarator

);



    // Struct definitions for testing

    typedef struct packed {

        logic [7:0] addr;

        logic [15:0] data;

        logic valid;

    } simple_struct_t;
      ^^^^^^^^^^^^^^^ Sym simple_struct_t : TypedefDeclaration



    typedef struct packed {

        simple_struct_t inner;
        ^^^^^^^^^^^^^^^ Ref -> `// Struct definitions for testing\n\typedef struct packed {\n\    logic [7:0] addr;\n\    logic [15:0] data;\n\    logic valid;\n\} simple_struct_t;`

        logic [3:0] tag;

        logic enable;

    } nested_struct_t;
      ^^^^^^^^^^^^^^^ Sym nested_struct_t : TypedefDeclaration



    // Variables for testing

    simple_struct_t single_struct;
    ^^^^^^^^^^^^^^^ Ref -> `// Struct definitions for testing\n\typedef struct packed {\n\    logic [7:0] addr;\n\    logic [15:0] data;\n\    logic valid;\n\} simple_struct_t;`
                    ^^^^^^^^^^^^^ Sym single_struct : Declarator

    simple_struct_t struct_array[4];
    ^^^^^^^^^^^^^^^ Ref -> `// Struct definitions for testing\n\typedef struct packed {\n\    logic [7:0] addr;\n\    logic [15:0] data;\n\    logic valid;\n\} simple_struct_t;`
                    ^^^^^^^^^^^^ Sym struct_array : Declarator

    nested_struct_t nested_struct;
    ^^^^^^^^^^^^^^^ Ref -> `typedef struct packed {\n\    simple_struct_t inner;\n\    logic [3:0] tag;\n\    logic enable;\n\} nested_struct_t;`
                    ^^^^^^^^^^^^^ Sym nested_struct : Declarator

    nested_struct_t nested_array[2];
    ^^^^^^^^^^^^^^^ Ref -> `typedef struct packed {\n\    simple_struct_t inner;\n\    logic [3:0] tag;\n\    logic enable;\n\} nested_struct_t;`
                    ^^^^^^^^^^^^ Sym nested_array : Declarator

    test_pkg::packet_t pkg_struct;
    ^^^^^^^^ Ref -> `package test_pkg;`
              ^^^^^^^^ Ref -> `// In test_pkg`\n\\n\---\n\\n\`typedef struct packed {\n\    id_t id;\n\    logic [15:0] data;\n\} packet_t;`
                       ^^^^^^^^^^ Sym pkg_struct : Declarator

    test_pkg::packet_t pkg_array[3];
    ^^^^^^^^ Ref -> `package test_pkg;`
              ^^^^^^^^ Ref -> `// In test_pkg`\n\\n\---\n\\n\`typedef struct packed {\n\    id_t id;\n\    logic [15:0] data;\n\} packet_t;`
                       ^^^^^^^^^ Sym pkg_array : Declarator



    logic [1:0] index;
                ^^^^^ Sym index : Declarator

    logic [7:0] addr_val;
                ^^^^^^^^ Sym addr_val : Declarator

    logic [15:0] data_val;
                 ^^^^^^^^ Sym data_val : Declarator



    always_ff @(posedge clk) begin
                        ^^^ Ref -> `input logic clk`

        if (rst) begin
            ^^^ Ref -> `input logic rst`

            // Basic struct member assignment

            single_struct.addr <= 8'h00;
            ^^^^^^^^^^^^^ Ref -> `// Variables for testing\n\simple_struct_t single_struct;`
                          ^^^^ Ref -> `// In StructAssignmentTest::simple_struct_t`\n\\n\---\n\\n\`logic [7:0] addr;`

            single_struct.data <= 16'h0000;
            ^^^^^^^^^^^^^ Ref -> `// Variables for testing\n\simple_struct_t single_struct;`
                          ^^^^ Ref -> `// In StructAssignmentTest::simple_struct_t`\n\\n\---\n\\n\`logic [15:0] data;`

            single_struct.valid <= 1'b0;
            ^^^^^^^^^^^^^ Ref -> `// Variables for testing\n\simple_struct_t single_struct;`
                          ^^^^^ Ref -> `// In StructAssignmentTest::simple_struct_t`\n\\n\---\n\\n\`logic valid;`



            // Array index struct member assignment

            struct_array[0].addr <= 8'hAA;
            ^^^^^^^^^^^^ Ref -> `simple_struct_t struct_array[4];`
                            ^^^^ Ref -> `// In StructAssignmentTest::simple_struct_t`\n\\n\---\n\\n\`logic [7:0] addr;`

            struct_array[1].data <= 16'hBBBB;
            ^^^^^^^^^^^^ Ref -> `simple_struct_t struct_array[4];`
                            ^^^^ Ref -> `// In StructAssignmentTest::simple_struct_t`\n\\n\---\n\\n\`logic [15:0] data;`

            struct_array[2].valid <= 1'b1;
            ^^^^^^^^^^^^ Ref -> `simple_struct_t struct_array[4];`
                            ^^^^^ Ref -> `// In StructAssignmentTest::simple_struct_t`\n\\n\---\n\\n\`logic valid;`



            // Variable index struct member assignment

            struct_array[index].addr <= 8'hCC;
            ^^^^^^^^^^^^ Ref -> `simple_struct_t struct_array[4];`
                         ^^^^^ Ref -> `logic [1:0] index;`
                                ^^^^ Ref -> `// In StructAssignmentTest::simple_struct_t`\n\\n\---\n\\n\`logic [7:0] addr;`

            struct_array[index].data <= data_val;
            ^^^^^^^^^^^^ Ref -> `simple_struct_t struct_array[4];`
                         ^^^^^ Ref -> `logic [1:0] index;`
                                ^^^^ Ref -> `// In StructAssignmentTest::simple_struct_t`\n\\n\---\n\\n\`logic [15:0] data;`
                                        ^^^^^^^^ Ref -> `logic [15:0] data_val;`



            // Nested struct member assignment

            nested_struct.inner.addr <= 8'hDD;
            ^^^^^^^^^^^^^ Ref -> `nested_struct_t nested_struct;`
                          ^^^^^ Ref -> `// In StructAssignmentTest::nested_struct_t`\n\\n\---\n\\n\`simple_struct_t inner;`
                                ^^^^ Ref -> `// In StructAssignmentTest::simple_struct_t`\n\\n\---\n\\n\`logic [7:0] addr;`

            nested_struct.inner.data <= 16'hEEEE;
            ^^^^^^^^^^^^^ Ref -> `nested_struct_t nested_struct;`
                          ^^^^^ Ref -> `// In StructAssignmentTest::nested_struct_t`\n\\n\---\n\\n\`simple_struct_t inner;`
                                ^^^^ Ref -> `// In StructAssignmentTest::simple_struct_t`\n\\n\---\n\\n\`logic [15:0] data;`

            nested_struct.inner.valid <= 1'b0;
            ^^^^^^^^^^^^^ Ref -> `nested_struct_t nested_struct;`
                          ^^^^^ Ref -> `// In StructAssignmentTest::nested_struct_t`\n\\n\---\n\\n\`simple_struct_t inner;`
                                ^^^^^ Ref -> `// In StructAssignmentTest::simple_struct_t`\n\\n\---\n\\n\`logic valid;`

            nested_struct.tag <= 4'h5;
            ^^^^^^^^^^^^^ Ref -> `nested_struct_t nested_struct;`
                          ^^^ Ref -> `// In StructAssignmentTest::nested_struct_t`\n\\n\---\n\\n\`logic [3:0] tag;`

            nested_struct.enable <= 1'b1;
            ^^^^^^^^^^^^^ Ref -> `nested_struct_t nested_struct;`
                          ^^^^^^ Ref -> `// In StructAssignmentTest::nested_struct_t`\n\\n\---\n\\n\`logic enable;`



            // Nested struct array assignment

            nested_array[0].inner.addr <= 8'hFF;
            ^^^^^^^^^^^^ Ref -> `nested_struct_t nested_array[2];`
                            ^^^^^ Ref -> `// In StructAssignmentTest::nested_struct_t`\n\\n\---\n\\n\`simple_struct_t inner;`
                                  ^^^^ Ref -> `// In StructAssignmentTest::simple_struct_t`\n\\n\---\n\\n\`logic [7:0] addr;`

            nested_array[1].inner.data <= 16'h1234;
            ^^^^^^^^^^^^ Ref -> `nested_struct_t nested_array[2];`
                            ^^^^^ Ref -> `// In StructAssignmentTest::nested_struct_t`\n\\n\---\n\\n\`simple_struct_t inner;`
                                  ^^^^ Ref -> `// In StructAssignmentTest::simple_struct_t`\n\\n\---\n\\n\`logic [15:0] data;`

            nested_array[index].tag <= 4'h7;
            ^^^^^^^^^^^^ Ref -> `nested_struct_t nested_array[2];`
                         ^^^^^ Ref -> `logic [1:0] index;`
                                ^^^ Ref -> `// In StructAssignmentTest::nested_struct_t`\n\\n\---\n\\n\`logic [3:0] tag;`



            // Package struct member assignment

            pkg_struct.id <= 32'h123;
            ^^^^^^^^^^ Ref -> `test_pkg::packet_t pkg_struct;`
                       ^^ Ref -> `// In test_pkg::packet_t`\n\\n\---\n\\n\`id_t id;`

            pkg_struct.data <= 16'h5678;
            ^^^^^^^^^^ Ref -> `test_pkg::packet_t pkg_struct;`
                       ^^^^ Ref -> `// In test_pkg::packet_t`\n\\n\---\n\\n\`logic [15:0] data;`



            // Package struct array assignment

            pkg_array[0].id <= 32'h456;
            ^^^^^^^^^ Ref -> `test_pkg::packet_t pkg_array[3];`
                         ^^ Ref -> `// In test_pkg::packet_t`\n\\n\---\n\\n\`id_t id;`

            pkg_array[1].data <= 16'h9ABC;
            ^^^^^^^^^ Ref -> `test_pkg::packet_t pkg_array[3];`
                         ^^^^ Ref -> `// In test_pkg::packet_t`\n\\n\---\n\\n\`logic [15:0] data;`

            pkg_array[index].id <= {24'h0, addr_val};
            ^^^^^^^^^ Ref -> `test_pkg::packet_t pkg_array[3];`
                      ^^^^^ Ref -> `logic [1:0] index;`
                             ^^ Ref -> `// In test_pkg::packet_t`\n\\n\---\n\\n\`id_t id;`
                                           ^^^^^^^^ Ref -> `logic [7:0] addr_val;`



            index <= 2'b00;
            ^^^^^ Ref -> `logic [1:0] index;`

            addr_val <= 8'h11;
            ^^^^^^^^ Ref -> `logic [7:0] addr_val;`

            data_val <= 16'h2222;
            ^^^^^^^^ Ref -> `logic [15:0] data_val;`

        end else begin

            // Runtime assignments with expressions

            single_struct.addr <= addr_val + 8'h10;
            ^^^^^^^^^^^^^ Ref -> `// Variables for testing\n\simple_struct_t single_struct;`
                          ^^^^ Ref -> `// In StructAssignmentTest::simple_struct_t`\n\\n\---\n\\n\`logic [7:0] addr;`
                                  ^^^^^^^^ Ref -> `logic [7:0] addr_val;`

            single_struct.data <= data_val << 1;
            ^^^^^^^^^^^^^ Ref -> `// Variables for testing\n\simple_struct_t single_struct;`
                          ^^^^ Ref -> `// In StructAssignmentTest::simple_struct_t`\n\\n\---\n\\n\`logic [15:0] data;`
                                  ^^^^^^^^ Ref -> `logic [15:0] data_val;`

            single_struct.valid <= ~single_struct.valid;
            ^^^^^^^^^^^^^ Ref -> `// Variables for testing\n\simple_struct_t single_struct;`
                          ^^^^^ Ref -> `// In StructAssignmentTest::simple_struct_t`\n\\n\---\n\\n\`logic valid;`
                                    ^^^^^^^^^^^^^ Ref -> `// Variables for testing\n\simple_struct_t single_struct;`
                                                  ^^^^^ Ref -> `// In StructAssignmentTest::simple_struct_t`\n\\n\---\n\\n\`logic valid;`



            // Complex array indexing with struct members

            struct_array[index + 1].addr <= single_struct.addr;
            ^^^^^^^^^^^^ Ref -> `simple_struct_t struct_array[4];`
                         ^^^^^ Ref -> `logic [1:0] index;`
                                    ^^^^ Ref -> `// In StructAssignmentTest::simple_struct_t`\n\\n\---\n\\n\`logic [7:0] addr;`
                                            ^^^^^^^^^^^^^ Ref -> `// Variables for testing\n\simple_struct_t single_struct;`
                                                          ^^^^ Ref -> `// In StructAssignmentTest::simple_struct_t`\n\\n\---\n\\n\`logic [7:0] addr;`

            struct_array[addr_val[1:0]].data <= nested_struct.inner.data;
            ^^^^^^^^^^^^ Ref -> `simple_struct_t struct_array[4];`
                         ^^^^^^^^ Ref -> `logic [7:0] addr_val;`
                                        ^^^^ Ref -> `// In StructAssignmentTest::simple_struct_t`\n\\n\---\n\\n\`logic [15:0] data;`
                                                ^^^^^^^^^^^^^ Ref -> `nested_struct_t nested_struct;`
                                                              ^^^^^ Ref -> `// In StructAssignmentTest::nested_struct_t`\n\\n\---\n\\n\`simple_struct_t inner;`
                                                                    ^^^^ Ref -> `// In StructAssignmentTest::simple_struct_t`\n\\n\---\n\\n\`logic [15:0] data;`



            // Chained struct member assignments

            nested_struct.inner.addr <= struct_array[0].addr;
            ^^^^^^^^^^^^^ Ref -> `nested_struct_t nested_struct;`
                          ^^^^^ Ref -> `// In StructAssignmentTest::nested_struct_t`\n\\n\---\n\\n\`simple_struct_t inner;`
                                ^^^^ Ref -> `// In StructAssignmentTest::simple_struct_t`\n\\n\---\n\\n\`logic [7:0] addr;`
                                        ^^^^^^^^^^^^ Ref -> `simple_struct_t struct_array[4];`
                                                        ^^^^ Ref -> `// In StructAssignmentTest::simple_struct_t`\n\\n\---\n\\n\`logic [7:0] addr;`

            nested_struct.inner.data <= pkg_struct.data;
            ^^^^^^^^^^^^^ Ref -> `nested_struct_t nested_struct;`
                          ^^^^^ Ref -> `// In StructAssignmentTest::nested_struct_t`\n\\n\---\n\\n\`simple_struct_t inner;`
                                ^^^^ Ref -> `// In StructAssignmentTest::simple_struct_t`\n\\n\---\n\\n\`logic [15:0] data;`
                                        ^^^^^^^^^^ Ref -> `test_pkg::packet_t pkg_struct;`
                                                   ^^^^ Ref -> `// In test_pkg::packet_t`\n\\n\---\n\\n\`logic [15:0] data;`

            nested_struct.inner.valid <= pkg_array[index].id[0];
            ^^^^^^^^^^^^^ Ref -> `nested_struct_t nested_struct;`
                          ^^^^^ Ref -> `// In StructAssignmentTest::nested_struct_t`\n\\n\---\n\\n\`simple_struct_t inner;`
                                ^^^^^ Ref -> `// In StructAssignmentTest::simple_struct_t`\n\\n\---\n\\n\`logic valid;`
                                         ^^^^^^^^^ Ref -> `test_pkg::packet_t pkg_array[3];`
                                                   ^^^^^ Ref -> `logic [1:0] index;`



            // Multi-dimensional style access

            nested_array[index].inner.addr <= struct_array[addr_val[1:0]].addr;
            ^^^^^^^^^^^^ Ref -> `nested_struct_t nested_array[2];`
                         ^^^^^ Ref -> `logic [1:0] index;`
                                ^^^^^ Ref -> `// In StructAssignmentTest::nested_struct_t`\n\\n\---\n\\n\`simple_struct_t inner;`
                                      ^^^^ Ref -> `// In StructAssignmentTest::simple_struct_t`\n\\n\---\n\\n\`logic [7:0] addr;`
                                              ^^^^^^^^^^^^ Ref -> `simple_struct_t struct_array[4];`
                                                           ^^^^^^^^ Ref -> `logic [7:0] addr_val;`
                                                                          ^^^^ Ref -> `// In StructAssignmentTest::simple_struct_t`\n\\n\---\n\\n\`logic [7:0] addr;`

            nested_array[~index].inner.data <= pkg_array[index + 1].data;
            ^^^^^^^^^^^^ Ref -> `nested_struct_t nested_array[2];`
                          ^^^^^ Ref -> `logic [1:0] index;`
                                 ^^^^^ Ref -> `// In StructAssignmentTest::nested_struct_t`\n\\n\---\n\\n\`simple_struct_t inner;`
                                       ^^^^ Ref -> `// In StructAssignmentTest::simple_struct_t`\n\\n\---\n\\n\`logic [15:0] data;`
                                               ^^^^^^^^^ Ref -> `test_pkg::packet_t pkg_array[3];`
                                                         ^^^^^ Ref -> `logic [1:0] index;`
                                                                    ^^^^ Ref -> `// In test_pkg::packet_t`\n\\n\---\n\\n\`logic [15:0] data;`



            // Expression-based assignments

            pkg_struct.id <= {16'h0, addr_val, data_val[7:0]};
            ^^^^^^^^^^ Ref -> `test_pkg::packet_t pkg_struct;`
                       ^^ Ref -> `// In test_pkg::packet_t`\n\\n\---\n\\n\`id_t id;`
                                     ^^^^^^^^ Ref -> `logic [7:0] addr_val;`
                                               ^^^^^^^^ Ref -> `logic [15:0] data_val;`

            pkg_array[index].data <= single_struct.data ^ nested_struct.inner.data;
            ^^^^^^^^^ Ref -> `test_pkg::packet_t pkg_array[3];`
                      ^^^^^ Ref -> `logic [1:0] index;`
                             ^^^^ Ref -> `// In test_pkg::packet_t`\n\\n\---\n\\n\`logic [15:0] data;`
                                     ^^^^^^^^^^^^^ Ref -> `// Variables for testing\n\simple_struct_t single_struct;`
                                                   ^^^^ Ref -> `// In StructAssignmentTest::simple_struct_t`\n\\n\---\n\\n\`logic [15:0] data;`
                                                          ^^^^^^^^^^^^^ Ref -> `nested_struct_t nested_struct;`
                                                                        ^^^^^ Ref -> `// In StructAssignmentTest::nested_struct_t`\n\\n\---\n\\n\`simple_struct_t inner;`
                                                                              ^^^^ Ref -> `// In StructAssignmentTest::simple_struct_t`\n\\n\---\n\\n\`logic [15:0] data;`



            // Increment index for next cycle

            index <= index + 1;
            ^^^^^ Ref -> `logic [1:0] index;`
                     ^^^^^ Ref -> `logic [1:0] index;`

            addr_val <= addr_val + 8'h01;
            ^^^^^^^^ Ref -> `logic [7:0] addr_val;`
                        ^^^^^^^^ Ref -> `logic [7:0] addr_val;`

            data_val <= data_val + 16'h0011;
            ^^^^^^^^ Ref -> `logic [15:0] data_val;`
                        ^^^^^^^^ Ref -> `logic [15:0] data_val;`

        end

    end



    // Combinational assignments

    always_comb begin

        // Direct member assignments in combinational logic

        if (single_struct.valid) begin
            ^^^^^^^^^^^^^ Ref -> `// Variables for testing\n\simple_struct_t single_struct;`
                          ^^^^^ Ref -> `// In StructAssignmentTest::simple_struct_t`\n\\n\---\n\\n\`logic valid;`

            nested_struct.tag = struct_array[0].addr[3:0];
            ^^^^^^^^^^^^^ Ref -> `nested_struct_t nested_struct;`
                          ^^^ Ref -> `// In StructAssignmentTest::nested_struct_t`\n\\n\---\n\\n\`logic [3:0] tag;`
                                ^^^^^^^^^^^^ Ref -> `simple_struct_t struct_array[4];`

            nested_struct.enable = |pkg_struct.id;
            ^^^^^^^^^^^^^ Ref -> `nested_struct_t nested_struct;`
                          ^^^^^^ Ref -> `// In StructAssignmentTest::nested_struct_t`\n\\n\---\n\\n\`logic enable;`
                                    ^^^^^^^^^^ Ref -> `test_pkg::packet_t pkg_struct;`
                                               ^^ Ref -> `// In test_pkg::packet_t`\n\\n\---\n\\n\`id_t id;`

        end else begin

            nested_struct.tag = 4'h0;
            ^^^^^^^^^^^^^ Ref -> `nested_struct_t nested_struct;`
                          ^^^ Ref -> `// In StructAssignmentTest::nested_struct_t`\n\\n\---\n\\n\`logic [3:0] tag;`

            nested_struct.enable = 1'b0;
            ^^^^^^^^^^^^^ Ref -> `nested_struct_t nested_struct;`
                          ^^^^^^ Ref -> `// In StructAssignmentTest::nested_struct_t`\n\\n\---\n\\n\`logic enable;`

        end

    end



    // Initial block assignments

    initial begin

        single_struct.addr = 8'h77;
        ^^^^^^^^^^^^^ Ref -> `// Variables for testing\n\simple_struct_t single_struct;`
                      ^^^^ Ref -> `// In StructAssignmentTest::simple_struct_t`\n\\n\---\n\\n\`logic [7:0] addr;`

        single_struct.data = 16'h8888;
        ^^^^^^^^^^^^^ Ref -> `// Variables for testing\n\simple_struct_t single_struct;`
                      ^^^^ Ref -> `// In StructAssignmentTest::simple_struct_t`\n\\n\---\n\\n\`logic [15:0] data;`

        single_struct.valid = 1'b1;
        ^^^^^^^^^^^^^ Ref -> `// Variables for testing\n\simple_struct_t single_struct;`
                      ^^^^^ Ref -> `// In StructAssignmentTest::simple_struct_t`\n\\n\---\n\\n\`logic valid;`



        struct_array[3].addr = 8'h99;
        ^^^^^^^^^^^^ Ref -> `simple_struct_t struct_array[4];`
                        ^^^^ Ref -> `// In StructAssignmentTest::simple_struct_t`\n\\n\---\n\\n\`logic [7:0] addr;`

        struct_array[3].data = 16'hAAAA;
        ^^^^^^^^^^^^ Ref -> `simple_struct_t struct_array[4];`
                        ^^^^ Ref -> `// In StructAssignmentTest::simple_struct_t`\n\\n\---\n\\n\`logic [15:0] data;`

        struct_array[3].valid = 1'b0;
        ^^^^^^^^^^^^ Ref -> `simple_struct_t struct_array[4];`
                        ^^^^^ Ref -> `// In StructAssignmentTest::simple_struct_t`\n\\n\---\n\\n\`logic valid;`



        nested_array[1].inner.addr = 8'hBB;
        ^^^^^^^^^^^^ Ref -> `nested_struct_t nested_array[2];`
                        ^^^^^ Ref -> `// In StructAssignmentTest::nested_struct_t`\n\\n\---\n\\n\`simple_struct_t inner;`
                              ^^^^ Ref -> `// In StructAssignmentTest::simple_struct_t`\n\\n\---\n\\n\`logic [7:0] addr;`

        nested_array[1].inner.data = 16'hCCCC;
        ^^^^^^^^^^^^ Ref -> `nested_struct_t nested_array[2];`
                        ^^^^^ Ref -> `// In StructAssignmentTest::nested_struct_t`\n\\n\---\n\\n\`simple_struct_t inner;`
                              ^^^^ Ref -> `// In StructAssignmentTest::simple_struct_t`\n\\n\---\n\\n\`logic [15:0] data;`

        nested_array[1].tag = 4'hD;
        ^^^^^^^^^^^^ Ref -> `nested_struct_t nested_array[2];`
                        ^^^ Ref -> `// In StructAssignmentTest::nested_struct_t`\n\\n\---\n\\n\`logic [3:0] tag;`



        pkg_array[2].id = 32'hDEAD;
        ^^^^^^^^^ Ref -> `test_pkg::packet_t pkg_array[3];`
                     ^^ Ref -> `// In test_pkg::packet_t`\n\\n\---\n\\n\`id_t id;`

        pkg_array[2].data = 16'hBEEF;
        ^^^^^^^^^ Ref -> `test_pkg::packet_t pkg_array[3];`
                     ^^^^ Ref -> `// In test_pkg::packet_t`\n\\n\---\n\\n\`logic [15:0] data;`

    end



endmodule
